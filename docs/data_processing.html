<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>data_utils.data_processing API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>data_utils.data_processing</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from comet_ml import Experiment                         # Comet.ml can log training metrics, parameters, do version control and parameter optimization
import torch                                            # PyTorch to create and apply deep learning models
import dask.dataframe as dd                             # Dask to handle big data in dataframes
import math                                             # Some mathematical operations
import numpy as np                                      # NumPy to handle numeric and NaN operations
import numbers                                          # numbers allows to check if data is numeric
import warnings                                         # Print warnings for bad practices
from functools import partial                           # Enables using functions with some fixed parameters
from tqdm.auto import tqdm                              # tqdm allows to track code execution progress
from glob import glob                                   # Find files by name
from . import utils                                     # Generic and useful methods
from . import search_explore                            # Methods to search and explore data
import data_utils as du

# Pandas to handle the data in dataframes
if du.use_modin is True:
    import modin.pandas as pd
else:
    import pandas as pd

# Ignore Dask&#39;s &#39;meta&#39; warning
warnings.filterwarnings(&#34;ignore&#34;, message=&#34;`meta` is not specified, inferred from partial data. Please provide `meta` if the result is unexpected.&#34;)

# Methods

def get_clean_label(orig_label, clean_labels, column_name=None):
    &#39;&#39;&#39;Gets the clean version of a given label.

    Parameters
    ----------
    orig_label : string
        Original label name that needs to be converted to the new format.
    clean_labels : dict
        Dictionary that converts each original label into a new, cleaner designation.
    column_name : string, default None
        Optional parameter to indicate a column name, which is used to specify better the
        missing values.

    Returns
    -------
    key : string
        Returns the dictionary key from clean_labels that corresponds to the translation
        given to the input label orig_label.
    &#39;&#39;&#39;
    for key in clean_labels:
        if orig_label in clean_labels[key]:
            return key

    # Remaining labels (or lack of one) are considered as missing data
    if column_name is not None:
        return f&#39;{column_name}_missing_value&#39;
    else:
        return &#39;missing_value&#39;


def rename_index(df, name):
    &#39;&#39;&#39;Renames the dataframe&#39;s index to a desired name. Specially important
    for dask dataframes, as they don&#39;t support any elegant, one-line method
    for this.

    Parameters
    ----------
    df : pandas.DataFrame or dask.DataFrame
        Dataframe whose index column will be renamed.
    name : string
        The new name for the index column.

    Returns
    -------
    df : dask.DataFrame
        Dataframe with a renamed index column.
    &#39;&#39;&#39;
    if isinstance(df, dd.DataFrame):
        feat_names = set(df.columns)
        df = df.reset_index()
        orig_idx_name = set(df.columns) - feat_names
        orig_idx_name = orig_idx_name.pop()
        df = df.rename(columns={orig_idx_name: name})
        df = df.set_index(name)
    elif isinstance(df, pd.DataFrame):
        df.index.names = [name]
    else:
        raise Exception(f&#39;ERROR: Input &#34;df&#34; should either be a pandas dataframe or a dask dataframe, not type {type(df)}.&#39;)
    return df


def standardize_missing_values(x, specific_nan_strings=[]):
    &#39;&#39;&#39;Apply function to be used in replacing missing value representations with
    the standard NumPy NaN value.

    Parameters
    ----------
    x : str, int or float
        Value to be analyzed and replaced with NaN, if it has a missing value
        representation.
    specific_nan_strings : list of strings, default []
        Parameter where the user can specify additional strings that
        should correspond to missing values.

    Returns
    -------
    x : str, int or float
        Corrected value, with standardized missing value representation.
    &#39;&#39;&#39;
    if isinstance(x, str):
        if utils.is_string_nan(x, specific_nan_strings):
            return np.nan
        else:
            return x
    else:
        return x


def standardize_missing_values_df(df, see_progress=True, specific_nan_strings=[]):
    &#39;&#39;&#39;Replace all elements in a dataframe that have a missing value
    representation with the standard NumPy NaN value.

    Parameters
    ----------
    df : pandas.DataFrame or dask.DataFrame
        Dataframe to be analyzed and have its content replaced with NaN,
        wherever a missing value representation is found.
    see_progress : bool, default True
        If set to True, a progress bar will show up indicating the execution
        of the normalization calculations.
    specific_nan_strings : list of strings, default []
        Parameter where the user can specify additional strings that
        should correspond to missing values.

    Returns
    -------
    df : pandas.DataFrame or dask.DataFrame
        Corrected dataframe, with standardized missing value representation.
    &#39;&#39;&#39;
    for feature in utils.iterations_loop(df.columns, see_progress=see_progress):
        if isinstance(df, dd.DataFrame):
            df[feature] = df[feature].apply(lambda x: standardize_missing_values(x, specific_nan_strings),
                                            meta=df[feature]._meta.dtypes)
        elif isinstance(df, pd.DataFrame):
            df[feature] = df[feature].apply(lambda x: standardize_missing_values(x, specific_nan_strings))
        else:
            raise Exception(f&#39;ERROR: Input &#34;df&#34; should either be a pandas dataframe or a dask dataframe, not type {type(df)}.&#39;)
    return df


def remove_cols_with_many_nans(df, nan_percent_thrsh=40, inplace=False):
    &#39;&#39;&#39;Remove columns that have too many NaN&#39;s (missing values).

    Parameters
    ----------
    df : pandas.DataFrame or dask.DataFrame
        Dataframe that will be processed, to remove columns with high
        percentages of missing values.
    nan_percent_thrsh : int or float, default 40
        Threshold value above which it&#39;s considered a column with too
        many missing values. Measured in percentage of missing values,
        in 100% format.
    inplace : bool, default False
        If set to True, the original dataframe will be used and modified
        directly. Otherwise, a copy will be created and returned, without
        changing the original dataframe.

    Returns
    -------
    df : pandas.DataFrame or dask.DataFrame
        Corrected dataframe, with columns removed that had too many
        missing values.
    &#39;&#39;&#39;
    if not inplace:
        # Make a copy of the data to avoid potentially unwanted changes to the original dataframe
        data_df = df.copy()
    else:
        # Use the original dataframe
        data_df = df
    # Find each column&#39;s missing values percentage
    nan_percent_df = search_explore.dataframe_missing_values(data_df)
    # Remove columns that exceed the missing values percentage threshold
    many_nans_cols = list(nan_percent_df[nan_percent_df.percent_missing &gt; nan_percent_thrsh].column_name)
    data_df = data_df.drop(many_nans_cols, axis = 1)
    return data_df


def clean_naming(x, lower_case=True):
    &#39;&#39;&#39;Change strings to only have lower case letters and underscores.

    Parameters
    ----------
    x : string or list of strings
        String(s) on which to clean the naming, standardizing it.
    lower_case : bool, default True
        If set to True, all strings will be converted to lower case.

    Returns
    -------
    x : string or list of strings
        Cleaned string(s).
    &#39;&#39;&#39;
    if &#39;pandas.core.indexes.base.Index&#39; in str(type(x)):
        # If the user input is a dataframe index (e.g. df.columns), convert it to a list
        x = list(x)
    if isinstance(x, list):
        if lower_case is True:
            x = [string.lower().replace(&#39;  &#39;, &#39;&#39;)
                               .replace(&#39; &#39;, &#39;_&#39;)
                               .replace(&#39;,&#39;, &#39;_and&#39;) for string in x]
        else:
            x = [string.replace(&#39;  &#39;, &#39;&#39;)
                       .replace(&#39; &#39;, &#39;_&#39;)
                       .replace(&#39;,&#39;, &#39;_and&#39;) for string in x]
    elif (isinstance(x, pd.DataFrame)
    or isinstance(x, pd.Series)
    or isinstance(x, dd.DataFrame)
    or isinstance(x, dd.Series)):
        raise Exception(&#39;ERROR: Wrong method. When using dataframes or series, use clean_categories_naming() method instead.&#39;)
    else:
        if lower_case is True:
            x = (str(x).lower().replace(&#39;  &#39;, &#39;&#39;)
                               .replace(&#39; &#39;, &#39;_&#39;)
                               .replace(&#39;,&#39;, &#39;_and&#39;))
        else:
            x = (str(x).replace(&#39;  &#39;, &#39;&#39;)
                       .replace(&#39; &#39;, &#39;_&#39;)
                       .replace(&#39;,&#39;, &#39;_and&#39;))
    return x


def clean_categories_naming(df, column, clean_missing_values=True,
                            specific_nan_strings=[], lower_case=False):
    &#39;&#39;&#39;Change categorical values to only have lower case letters and underscores.

    Parameters
    ----------
    df : pandas.DataFrame or dask.DataFrame
        Dataframe that contains the column to be cleaned.
    column : string
        Name of the dataframe&#39;s column which needs to have its string values
        standardized.
    clean_missing_values : bool, default True
        If set to True, the algorithm will search for missing value
        representations and replace them with the standard, NumPy NaN value.
    specific_nan_strings : list of strings, default []
        Parameter where the user can specify additional strings that
        should correspond to missing values.
    lower_case : bool, default False
        If set to True, all strings will be converted to lower case.

    Returns
    -------
    df : pandas.DataFrame or dask.DataFrame
        Dataframe with its string column already cleaned.
    &#39;&#39;&#39;
    # Fix the seeting of all lower case characters according to the `lower_case` parameter
    clean_naming_prtl = partial(clean_naming, lower_case=lower_case)
    if isinstance(df, dd.DataFrame):
        df[column] = (df[column].map(clean_naming_prtl, meta=(&#39;x&#39;, str)))
        if clean_missing_values is True:
            df[column] = df[column].apply(lambda x: standardize_missing_values(x, specific_nan_strings),
                                          meta=df[column]._meta.dtypes)
    else:
        df[column] = (df[column].map(clean_naming_prtl))
        if clean_missing_values is True:
            df[column] = df[column].apply(lambda x: standardize_missing_values(x, specific_nan_strings))
    return df


def one_hot_encoding_dataframe(df, columns, clean_name=True, clean_missing_values=True,
                               specific_nan_strings=[], lower_case=False,
                               has_nan=False, join_rows=False,
                               join_by=[&#39;patientunitstayid&#39;, &#39;ts&#39;],
                               get_new_column_names=False,
                               search_by_dtypes=False, inplace=False):
    &#39;&#39;&#39;Transforms specified column(s) from a dataframe into a one hot encoding
    representation.

    Parameters
    ----------
    df : pandas.DataFrame or dask.DataFrame
        Dataframe that will be used, which contains the specified column.
    columns : list of strings
        Name of the column(s) that will be conveted to one hot encoding.
    clean_name : bool, default True
        If set to true, changes the name of the categorical values into lower
        case, with words separated by an underscore instead of space.
    clean_missing_values : bool, default True
        If set to True, the algorithm will search for missing value
        representations and replace them with the standard, NumPy NaN value.
    specific_nan_strings : list of strings, default []
        Parameter where the user can specify additional strings that
        should correspond to missing values.
    lower_case : bool, default False
        If set to True, all strings will be converted to lower case.
    has_nan : bool, default False
        If set to true, will first fill the missing values (NaN) with the string
        f&#39;{column}_missing_value&#39;.
    join_rows : bool, default False
        If set to true, will group the rows created by the one hot encoding by
        summing the boolean values in the rows that have the same identifiers.
    join_by : string or list, default [&#39;subject_id&#39;, &#39;ts&#39;])
        Name of the column (or columns) which serves as a unique identifier of
        the dataframe&#39;s rows, which will be used in the groupby operation if the
        parameter join_rows is set to true. Can be a string (single column) or a
        list of strings (multiple columns).
    get_new_column_names : bool, default False
        If set to True, the names of the new columns will also be outputed.
    search_by_dtypes : bool, default False
        If set to True, the method will only look for boolean columns based on
        their data type. This is only reliable if all the columns&#39; data types
        have been properly set.
    inplace : bool, default False
        If set to True, the original dataframe will be used and modified
        directly. Otherwise, a copy will be created and returned, without
        changing the original dataframe.

    Raises
    ------
    ColumnNotFoundError
        Column name not found in the dataframe.

    Returns
    -------
    ohe_df : pandas.DataFrame or dask.DataFrame
        Returns a new dataframe with the specified column in a one hot encoding
        representation.
    new_column_names : list of strings
        List of the new, one hot encoded columns&#39; names.
    &#39;&#39;&#39;
    if not inplace:
        # Make a copy of the data to avoid potentially unwanted changes to the original dataframe
        data_df = df.copy()
    else:
        # Use the original dataframe
        data_df = df
    # Make sure that the columns is a list
    if isinstance(columns, str):
        columns = [columns]
    if not isinstance(columns, list):
        raise Exception(f&#39;ERROR: The `columns` argument must be specified as either a single string or a list of strings. Received input with type {type(columns)}.&#39;)
    print(&#39;Cleaning the categorical columns...&#39;)
    for col in utils.iterations_loop(columns):
        # Check if the column exists
        if col not in data_df.columns:
            raise Exception(&#39;ERROR: Column name not found in the dataframe.&#39;)
        if clean_name is True:
            # Clean the column&#39;s string values to have the same, standard format
            data_df = clean_categories_naming(data_df, col, clean_missing_values,
                                              specific_nan_strings, lower_case)
        if has_nan is True:
            # Fill NaN with &#34;missing_value&#34; name
            data_df[col] = data_df[col].fillna(value=&#39;missing_value&#39;)
        # Cast the variable into the built in pandas Categorical data type
        if isinstance(data_df, pd.DataFrame):
            data_df[col] = pd.Categorical(data_df[col])
    if isinstance(data_df, dd.DataFrame):
        data_df = data_df.categorize(columns)
    if get_new_column_names is True:
        # Find the previously existing column names
        old_column_names = data_df.columns
    print(&#39;Getting dummies...&#39;)
    # Apply the one hot encoding to the specified columns
    if isinstance(data_df, dd.DataFrame):
        ohe_df = dd.get_dummies(data_df, columns=columns)
    else:
        ohe_df = pd.get_dummies(data_df, columns=columns)
    if join_rows is True:
        # Columns which are one hot encoded
        ohe_columns = search_explore.list_boolean_columns(ohe_df, search_by_dtypes=search_by_dtypes)
        # Group the rows that have the same identifiers
        ohe_df = ohe_df.groupby(join_by).sum(min_count=1).reset_index()
        # Clip the one hot encoded columns to a maximum value of 1
        # (there might be duplicates which cause values bigger than 1)
        ohe_df.loc[:, ohe_columns] = ohe_df[ohe_columns].clip(upper=1)
    print(&#39;Done!&#39;)
    if get_new_column_names is True:
        # Find the new column names and output them
        new_column_names = list(set(ohe_df.columns) - set(old_column_names))
        new_column_names.sort()
        return ohe_df, new_column_names
    else:
        return ohe_df


def category_to_feature(df, categories_feature, values_feature, min_len=None,
                        see_progress=True, inplace=False):
    &#39;&#39;&#39;Convert a categorical column and its corresponding values column into
    new features, one for each category.
    WARNING: Currently not working properly on a Dask dataframe. Apply .compute()
    to the dataframe to convert it to Pandas, before passing it to this method.
    If the data is too big to run on Pandas, use the category_to_feature_big_data
    method.

    Parameters
    ----------
    df : pandas.DataFrame or dask.DataFrame
        Dataframe on which to add the new features.
    categories_feature : string
        Name of the feature that contains the categories that will be converted
        to individual features.
    values_feature : string
        Name of the feature that has each category&#39;s corresponding value, which
        may or may not be a category on its own (e.g. it could be numeric values).
    min_len : int, default None
        If defined, only the categories that appear on at least `min_len` rows
        are converted to features.
    see_progress : bool, default True
        If set to True, a progress bar will show up indicating the execution
        of the normalization calculations.
    inplace : bool, default False
        If set to True, the original dataframe will be used and modified
        directly. Otherwise, a copy will be created and returned, without
        changing the original dataframe.

    Returns
    -------
    data_df : pandas.DataFrame or dask.DataFrame
        Dataframe with the newly created features.
    &#39;&#39;&#39;
    if not inplace:
        # Make a copy of the data to avoid potentially unwanted changes to the original dataframe
        data_df = df.copy()
    else:
        # Use the original dataframe
        data_df = df
    # Find the unique categories
    categories = data_df[categories_feature].unique()
    if isinstance(df, dd.DataFrame):
        categories = categories.compute()
    # Create a feature for each category
    for category in utils.iterations_loop(categories, see_progress=see_progress):
        if min_len is not None:
            # Check if the current category has enough data to be worth it to convert to a feature
            if len(data_df[data_df[categories_feature] == category]) &lt; min_len:
                # Ignore the current category
                continue
        # Convert category to feature
        data_df[category] = data_df.apply(lambda x: x[values_feature] if x[categories_feature] == category
                                                    else np.nan, axis=1)
    return data_df


def category_to_feature_big_data(df, categories_feature, values_feature,
                                 min_len=None, see_progress=True):
    &#39;&#39;&#39;Convert a categorical column and its corresponding values column into
    new features, one for each category. Optimized for very big Dask dataframes,
    which can&#39;t be processed as a whole Pandas dataframe.

    Parameters
    ----------
    df : dask.DataFrame
        Dataframe on which to add the new features.
    categories_feature : string
        Name of the feature that contains the categories that will be converted
        to individual features.
    values_feature : string
        Name of the feature that has each category&#39;s corresponding value, which
        may or may not be a category on its own (e.g. it could be numeric values).
    min_len : int, default None
        If defined, only the categories that appear on at least `min_len` rows
        are converted to features.
    see_progress : bool, default True
        If set to True, a progress bar will show up indicating the execution
        of the normalization calculations.

    Returns
    -------
    data_df : dask.DataFrame
        Dataframe with the newly created features.
    &#39;&#39;&#39;
    # Create a list with Pandas dataframe versions of each partition of the
    # original Dask dataframe
    df_list = []
    print(&#39;Converting categories to features in each partition...&#39;)
    for n in utils.iterations_loop(range(df.npartitions), see_progress=see_progress):
        # Process each partition separately in Pandas
        tmp_df = df.get_partition(n).compute()
        tmp_df = category_to_feature(tmp_df, categories_feature=categories_feature,
                                     values_feature=values_feature, min_len=min_len,
                                     see_progress=see_progress)
        df_list.append(tmp_df)
    # Rejoin all the partitions into a Dask dataframe with the same number of
    # partitions it originally had
    print(&#39;Rejoining partitions into a Dask dataframe...&#39;)
    data_df = dd.from_pandas(pd.concat(df_list, sort=False), npartitions=df.npartitions)
    print(&#39;Done!&#39;)
    return data_df


def remove_rows_unmatched_key(df, key, columns):
    &#39;&#39;&#39;Remove rows corresponding to the keys that weren&#39;t in the dataframe merged at the right.

    Parameters
    ----------
    df : pandas.DataFrame or dask.DataFrame
        Dataframe resulting from a asof merge which will be searched for missing values.
    key : string
        Name of the column which was used as the &#34;by&#34; key in the asof merge. Typically
        represents a temporal feature from a time series, such as days or timestamps.
    columns : list of strings
        Name of the column(s), originating from the dataframe which was merged at the
        right, which should not have any missing values. If it has, it means that
        the corresponding key wasn&#39;t present in the original dataframe. Even if there&#39;s
        just one column to analyze, it should be received in list format.

    Returns
    -------
    df : pandas.DataFrame or dask.DataFrame
        Returns the input dataframe but without the rows which didn&#39;t have any values
        in the right dataframe&#39;s features.
    &#39;&#39;&#39;
    for k in utils.iterations_loop(df[key].unique()):
        # Variable that counts the number of columns which don&#39;t have any value
        # (i.e. all rows are missing values) for a given identifier &#39;k&#39;
        num_empty_columns = 0
        for col in columns:
            if df[df[key] == k][col].isnull().sum() == len(df[df[key] == k]):
                # Found one more column which is full of missing values for identifier &#39;k&#39;
                num_empty_columns += 1
        if num_empty_columns == len(columns):
            # Eliminate all rows corresponding to the analysed key if all the columns
            # are empty for the identifier &#39;k&#39;
            df = df[~(df[key] == k)]
    return df


def apply_zscore_norm(value, df=None, mean=None, std=None, categories_means=None,
                      categories_stds=None, groupby_columns=None):
    &#39;&#39;&#39;Performs z-score normalization when used inside a Pandas or Dask
    apply function.

    Parameters
    ----------
    value : int or float
        Original, unnormalized value.
    df : pandas.DataFrame or dask.DataFrame, default None
        Original pandas dataframe which is used to retrieve the
        necessary statistical values used in group normalization, i.e. when
        values are normalized according to their corresponding categories.
    mean : int or float, default None
        Average (mean) value to be used in the z-score normalization.
    std : int or float, default None
        Standard deviation value to be used in the z-score normalization.
    categories_means : dict, default None
        Dictionary containing the average values for each set of categories.
    categories_stds : dict, default None
        Dictionary containing the standard deviation values for each set of
        categories.
    groupby_columns : string or list of strings, default None
        Name(s) of the column(s) that contains the categories from which
        statistical values (mean and standard deviation) are retrieved.

    Returns
    -------
    value_norm : int or float
        Z-score normalized value.
    &#39;&#39;&#39;
    if not isinstance(value, numbers.Number):
        raise Exception(f&#39;ERROR: Input value should be a number, not an object of type {type(value)}.&#39;)
    if mean is not None and std is not None:
        return (value - mean) / std
    elif (df is not None and categories_means is not None
          and categories_stds is not None and groupby_columns is not None):
        try:
            if isinstance(groupby_columns, list):
                return ((value - categories_means[tuple(df[groupby_columns])])
                        / categories_stds[tuple(df[groupby_columns])])
            else:
                return ((value - categories_means[df[groupby_columns]])
                        / categories_stds[df[groupby_columns]])
        except Exception:
            warnings.warn(f&#39;Couldn\&#39;t manage to find the mean and standard deviation values for the groupby columns {groupby_columns} with values {tuple(df[groupby_columns])}.&#39;)
            return np.nan
    else:
        raise Exception(&#39;ERROR: Invalid parameters. Either the `mean` and `std` or the `df`, `categories_means`, `categories_stds` and `groupby_columns` must be set.&#39;)


def apply_minmax_norm(value, df=None, min=None, max=None, categories_mins=None,
                      categories_maxs=None, groupby_columns=None):
    &#39;&#39;&#39;Performs minmax normalization when used inside a Pandas or Dask
    apply function.

    Parameters
    ----------
    value : int or float
        Original, unnormalized value.
    df : pandas.DataFrame or dask.DataFrame, default None
        Original pandas dataframe which is used to retrieve the
        necessary statistical values used in group normalization, i.e. when
        values are normalized according to their corresponding categories.
    min : int or float, default None
        Minimum value to be used in the minmax normalization.
    max : int or float, default None
        Maximum value to be used in the minmax normalization.
    categories_mins : dict, default None
        Dictionary containing the minimum values for each set of categories.
    categories_maxs : dict, default None
        Dictionary containing the maximum values for each set of categories.
    groupby_columns : string or list of strings, default None
        Name(s) of the column(s) that contains the categories from which
        statistical values (minimum and maximum) are retrieved.

    Returns
    -------
    value_norm : int or float
        Minmax normalized value.
    &#39;&#39;&#39;
    if not isinstance(value, numbers.Number):
        raise Exception(f&#39;ERROR: Input value should be a number, not an object of type {type(value)}.&#39;)
    if min and max:
        return (value - min) / (max - min)
    elif df and categories_mins and categories_maxs and groupby_columns:
        try:
            if isinstance(groupby_columns, list):
                return ((value - categories_mins[tuple(df[groupby_columns])])
                        / (categories_maxs[tuple(df[groupby_columns])] - categories_mins[tuple(df[groupby_columns])]))
            else:
                return ((value - categories_mins[df[groupby_columns]])
                        / (categories_maxs[df[groupby_columns]] - categories_mins[df[groupby_columns]]))
        except Exception:
            warnings.warn(f&#39;Couldn\&#39;t manage to find the mean and standard deviation values for the groupby columns {groupby_columns} with values {tuple(df[groupby_columns])}.&#39;)
            return np.nan
    else:
        raise Exception(&#39;ERROR: Invalid parameters. Either the `min` and `max` or the `df`, `categories_mins`, `categories_maxs` and `groupby_columns` must be set.&#39;)


def apply_zscore_denorm(value, df=None, mean=None, std=None, categories_means=None,
                      categories_stds=None, groupby_columns=None):
    &#39;&#39;&#39;Performs z-score denormalization when used inside a Pandas or Dask
    apply function.

    Parameters
    ----------
    value : int or float
        Input normalized value.
    df : pandas.DataFrame or dask.DataFrame, default None
        Original pandas dataframe which is used to retrieve the
        necessary statistical values used in group denormalization, i.e. when
        values are denormalized according to their corresponding categories.
    mean : int or float, default None
        Average (mean) value to be used in the z-score denormalization.
    std : int or float, default None
        Standard deviation value to be used in the z-score denormalization.
    categories_means : dict, default None
        Dictionary containing the average values for each set of categories.
    categories_stds : dict, default None
        Dictionary containing the standard deviation values for each set of
        categories.
    groupby_columns : string or list of strings, default None
        Name(s) of the column(s) that contains the categories from which
        statistical values (mean and standard deviation) are retrieved.

    Returns
    -------
    value_denorm : int or float
        Z-score denormalized value.
    &#39;&#39;&#39;
    if not isinstance(value, numbers.Number):
        raise Exception(f&#39;ERROR: Input value should be a number, not an object of type {type(value)}.&#39;)
    if mean is not None and std is not None:
        return value * std + mean
    elif (df is not None and categories_means is not None
          and categories_stds is not None and groupby_columns is not None):
        try:
            if isinstance(groupby_columns, list):
                return (value * categories_stds[tuple(df[groupby_columns])]
                        + categories_means[tuple(df[groupby_columns])])
            else:
                return (value * categories_stds[df[groupby_columns]]
                        + categories_means[df[groupby_columns]])
        except Exception:
            warnings.warn(f&#39;Couldn\&#39;t manage to find the mean and standard deviation values for the groupby columns {groupby_columns} with values {tuple(df[groupby_columns])}.&#39;)
            return np.nan
    else:
        raise Exception(&#39;ERROR: Invalid parameters. Either the `mean` and `std` or the `df`, `categories_means`, `categories_stds` and `groupby_columns` must be set.&#39;)


def apply_minmax_denorm(value, df=None, min=None, max=None, categories_mins=None,
                      categories_maxs=None, groupby_columns=None):
    &#39;&#39;&#39;Performs minmax denormalization when used inside a Pandas or Dask
    apply function.

    Parameters
    ----------
    value : int or float
        Input normalized value.
    df : pandas.DataFrame or dask.DataFrame, default None
        Original pandas dataframe which is used to retrieve the
        necessary statistical values used in group denormalization, i.e. when
        values are denormalized according to their corresponding categories.
    min : int or float, default None
        Minimum value to be used in the minmax denormalization.
    max : int or float, default None
        Maximum value to be used in the minmax denormalization.
    categories_mins : dict, default None
        Dictionary containing the minimum values for each set of categories.
    categories_maxs : dict, default None
        Dictionary containing the maximum values for each set of categories.
    groupby_columns : string or list of strings, default None
        Name(s) of the column(s) that contains the categories from which
        statistical values (minimum and maximum) are retrieved.

    Returns
    -------
    value_denorm : int or float
        Minmax denormalized value.
    &#39;&#39;&#39;
    if not isinstance(value, numbers.Number):
        raise Exception(f&#39;ERROR: Input value should be a number, not an object of type {type(value)}.&#39;)
    if min is not None and max is not None:
        return value * (max - min) + min
    elif (df is not None and categories_mins is not None
          and categories_maxs is not None and groupby_columns is not None):
        try:
            if isinstance(groupby_columns, list):
                return (value * (categories_maxs[tuple(df[groupby_columns])]
                        - categories_mins[tuple(df[groupby_columns])])
                        + categories_mins[tuple(df[groupby_columns])])
            else:
                return (value * (categories_maxs[df[groupby_columns]]
                        - categories_mins[df[groupby_columns]])
                        + categories_mins[df[groupby_columns]])
        except Exception:
            warnings.warn(f&#39;Couldn\&#39;t manage to find the mean and standard deviation values for the groupby columns {groupby_columns} with values {tuple(df[groupby_columns])}.&#39;)
            return np.nan
    else:
        raise Exception(&#39;ERROR: Invalid parameters. Either the `min` and `max` or the `df`, `categories_mins`, `categories_maxs` and `groupby_columns` must be set.&#39;)


def normalize_data(df, data=None, id_columns=[&#39;patientunitstayid&#39;, &#39;ts&#39;],
                   normalization_method=&#39;z-score&#39;, columns_to_normalize=None,
                   columns_to_normalize_categ=None, categ_columns=None,
                   see_progress=True, get_stats=False,
                   search_by_dtypes=False, inplace=False):
    &#39;&#39;&#39;Performs data normalization to a continuous valued tensor or dataframe,
       changing the scale of the data.

    Parameters
    ----------
    df : pandas.DataFrame or dask.DataFrame
        Original Pandas or Dask dataframe which is used to correctly calculate the
        necessary statistical values used in the normalization. These values
        can&#39;t be calculated from the tensor as it might have been padded. If
        the data tensor isn&#39;t specified, the normalization is applied directly
        on the dataframe.
    data : torch.Tensor, default None
        PyTorch tensor corresponding to the data which will be normalized
        by the specified normalization method. If the data tensor isn&#39;t
        specified, the normalization is applied directly on the dataframe.
    id_columns : string or list of strings, default [&#39;subject_id&#39;, &#39;ts&#39;]
        List of columns names which represent identifier columns. These are not
        supposed to be normalized.
    normalization_method : string, default &#39;z-score&#39;
        Specifies the normalization method used. It can be a z-score
        normalization, where the data is subtracted of its mean and divided
        by the standard deviation, which makes it have zero average and unit
        variance, much like a standard normal distribution; it can be a
        min-max normalization, where the data is subtracted by its minimum
        value and then divided by the difference between the minimum and the
        maximum value, getting to a fixed range from 0 to 1.
    columns_to_normalize : string or list of strings, default None
        If specified, the columns provided in the list are the only ones that
        will be normalized. If set to False, no column will be normalized directly,
        although columns can still be normalized in groups of categories, if
        specified in the `columns_to_normalize_categ` parameter. Otherwise, all
        continuous columns will be normalized.
    columns_to_normalize_categ : tuple or list of tuples of tuples, default None
        If specified, the columns provided in the list are going to be
        normalized on their categories. That is, the values (column 2 in the
        tuple) are normalized with stats of their respective categories (column
        1 of the tuple). Otherwise, no column will be normalized on their
        categories.
    categ_columns : string or list of strings, default None
        If specified, the columns in the list, which represent categorical
        features, which either are a label or will be embedded, aren&#39;t
        going to be normalized.
    see_progress : bool, default True
        If set to True, a progress bar will show up indicating the execution
        of the normalization calculations.
    get_stats : bool, default False
        If set to True, the stats used to normalize the data (e.g. mean and
        standard deviation) are also outputed.
    search_by_dtypes : bool, default False
        If set to True, the method will only look for boolean columns based on
        their data type. This is only reliable if all the columns&#39; data types
        have been properly set.
    inplace : bool, default False
        If set to True, the original dataframe will be used and modified
        directly. Otherwise, a copy will be created and returned, without
        changing the original dataframe.

    Returns
    -------
    data : pandas.DataFrame or dask.DataFrame or torch.Tensor
        Normalized Pandas or Dask dataframe or PyTorch tensor.

    If get_stats == True and normalization_method == &#39;z-score&#39;:

    mean : float or dict or list of floats or list of dicts
        Mean value(s) used in the data normalization.
    std : float or dict or list of floats or list of dicts
        Standard deviation value(s) used in the data normalization.

    If get_stats == True and normalization_method == &#39;min-max&#39;:

    min : dict
        Minimum value(s) used in the data normalization.
    max : dict
        Maximum value(s) used in the data normalization.
    &#39;&#39;&#39;
    # Check if specific columns have been specified for normalization
    if columns_to_normalize is None:
        # List of all columns in the dataframe
        feature_columns = list(df.columns)
        # Normalize all non identifier continuous columns, ignore one hot encoded ones
        columns_to_normalize = feature_columns
        if id_columns is not None:
            # Make sure that the id_columns is a list
            if isinstance(id_columns, str):
                id_columns = [id_columns]
            if not isinstance(id_columns, list):
                raise Exception(f&#39;ERROR: The `id_columns` argument must be specified as either a single string or a list of strings. Received input with type {type(id_columns)}.&#39;)
            # List of all columns in the dataframe, except the ID columns
            [columns_to_normalize.remove(col) for col in id_columns]
        if categ_columns is not None:
            # Make sure that the categ_columns is a list
            if isinstance(categ_columns, str):
                categ_columns = [categ_columns]
            if not isinstance(categ_columns, list):
                raise Exception(f&#39;ERROR: The `categ_columns` argument must be specified as either a single string or a list of strings. Received input with type {type(categ_columns)}.&#39;)
            # Prevent all features that will be embedded from being normalized
            [columns_to_normalize.remove(col) for col in categ_columns]
        # List of boolean or one hot encoded columns
        boolean_cols = search_explore.list_boolean_columns(df[columns_to_normalize], search_by_dtypes=search_by_dtypes)
        if boolean_cols is not None:
            # Prevent boolean features from being normalized
            [columns_to_normalize.remove(col) for col in boolean_cols]
        # Remove all non numeric columns that could be left
        columns_to_normalize = [col for col in columns_to_normalize
                                if df[col].dtype == int or df[col].dtype == float]
        if columns_to_normalize is None:
            print(&#39;No columns to normalize, returning the original dataframe.&#39;)
            return df

    # Make sure that the columns_to_normalize is a list
    if isinstance(columns_to_normalize, str):
        columns_to_normalize = [columns_to_normalize]
    if not isinstance(columns_to_normalize, list) and not isinstance(columns_to_normalize, bool):
        raise Exception(f&#39;ERROR: The `columns_to_normalize` argument must be specified as either a single string, a list of strings or a boolean. Received input with type {type(columns_to_normalize)}.&#39;)

    if type(normalization_method) is not str:
        raise ValueError(&#39;Argument normalization_method should be a string. Available options are &#34;z-score&#34; and &#34;min-max&#34;.&#39;)

    if normalization_method.lower() == &#39;z-score&#39;:
        if columns_to_normalize is not False:
            # Calculate the means and standard deviations
            means = df[columns_to_normalize].mean()
            stds = df[columns_to_normalize].std()
            # Check if there are constant features
            const_feat = list(stds[stds == 0].index)
            if len(const_feat) &gt; 0:
                # Prevent constant features from being normalized
                [columns_to_normalize.remove(col) for col in const_feat]
                means = means.drop(const_feat)
                stds = stds.drop(const_feat)
                warnings.warn(f&#39;Found columns {const_feat} to be constant throughout all the data. They should be removed as no insight will be extracted from them.&#39;)

            if isinstance(df, dd.DataFrame):
                # Make sure that the values are computed, in case we&#39;re using Dask
                means = means.compute()
                stds = stds.compute()

        # Check if the data being normalized is directly the dataframe
        if data is None:
            if not inplace:
                # Make a copy of the data to avoid potentially unwanted changes to the original dataframe
                data = df.copy()
            else:
                # Use the original dataframe
                data = df

            # Normalize the right columns
            if columns_to_normalize is not False:
                print(f&#39;z-score normalizing columns {columns_to_normalize}...&#39;)
                data[columns_to_normalize] = (data[columns_to_normalize] - means) / stds

            if columns_to_normalize_categ is not None:
                if get_stats is True:
                    mean_list = []
                    std_list = []
                # Make sure that the columns_to_normalize_categ is a list
                if isinstance(columns_to_normalize_categ, tuple):
                    columns_to_normalize_categ = [columns_to_normalize_categ]
                if not isinstance(columns_to_normalize_categ, list):
                    raise Exception(f&#39;ERROR: The `columns_to_normalize_categ` argument must be specified as either a single tuple or a list of tuples. Received input with type {type(columns_to_normalize_categ)}.&#39;)
                print(f&#39;z-score normalizing columns {columns_to_normalize_categ} by their associated categories...&#39;)
                for col_tuple in utils.iterations_loop(columns_to_normalize_categ, see_progress=see_progress):
                    categ_columns = col_tuple[0]
                    column_to_normalize = col_tuple[1]
                    # Calculate the means and standard deviations
                    means_grpb = df.groupby(categ_columns)[column_to_normalize].mean()
                    stds_grpb = df.groupby(categ_columns)[column_to_normalize].std()
                    if isinstance(df, dd.DataFrame):
                        # Make sure that the values are computed, in case we&#39;re using Dask
                        means_grpb = means.compute()
                        stds_grpb = stds.compute()
                    if get_stats is True:
                        if isinstance(column_to_normalize, str):
                            # Make sure that the feature being normalized has its name specified in the stats
                            tmp_mean_grpb = dict()
                            tmp_std_grpb = dict()
                            tmp_mean_grpb[column_to_normalize] = means_grpb.to_dict()
                            tmp_std_grpb[column_to_normalize] = stds_grpb.to_dict()
                            # Add the current stats values to the output lists
                            mean_list.append(tmp_mean_grpb)
                            std_list.append(tmp_std_grpb)
                        else:
                            # Add the current stats values to the output lists
                            mean_list.append(means_grpb.to_dict())
                            std_list.append(stds_grpb.to_dict())
                    # Get the categories columns as a numpy array, so as to
                    # index the groupby-resulting dataframes of mean and standard
                    # deviation values
                    cat_arr = df[categ_columns].to_numpy()
                    if isinstance(categ_columns, list) and len(categ_columns) &gt; 1:
                        # Convert the sets of values into tuples so as to be
                        # properly readable as dataframe indices
                        cat_arr = list(map(tuple, cat_arr))
                    # Get the mean and standard deviation values in the same
                    # order as the original dataframe&#39;s row order
                    means_cat = means_grpb.loc[cat_arr].to_numpy()
                    stds_cat = stds_grpb.loc[cat_arr].to_numpy()
                    # Normalize the right categories
                    data[column_to_normalize] = (data[column_to_normalize] - means_cat) / stds_cat
                if get_stats is True:
                    # Merge all the stats dictionaries
                    mean_categ_dict = utils.merge_dicts(mean_list)
                    std_categ_dict = utils.merge_dicts(std_list)

        # Otherwise, the tensor is normalized
        else:
            if columns_to_normalize is not False:
                # Dictionaries to retrieve the mean and standard deviation values
                column_means = dict(means)
                column_stds = dict(stds)
                # Dictionary to convert the the tensor&#39;s column indices into the dataframe&#39;s column names
                idx_to_name = dict(enumerate(df.columns))
                # Dictionary to convert the dataframe&#39;s column names into the tensor&#39;s column indices
                name_to_idx = dict([(t[1], t[0]) for t in enumerate(df.columns)])
                # List of indices of the tensor&#39;s columns which are needing normalization
                tensor_columns_to_normalize = [name_to_idx[name] for name in columns_to_normalize]
                # Normalize the right columns
                print(f&#39;z-score normalizing columns {columns_to_normalize}...&#39;)
                for col in utils.iterations_loop(tensor_columns_to_normalize, see_progress=see_progress):
                    data[:, :, col] = ((data[:, :, col] - column_means[idx_to_name[col]])
                                       / column_stds[idx_to_name[col]])

        if get_stats is False:
            return data
        elif columns_to_normalize is not False and columns_to_normalize_categ is not None:
            return data, means.to_dict(), stds.to_dict(), mean_categ_dict, std_categ_dict
        elif columns_to_normalize is not False and columns_to_normalize_categ is None:
            return data, means.to_dict(), stds.to_dict()
        elif columns_to_normalize is False and columns_to_normalize_categ is not None:
            return data, mean_categ_dict, std_categ_dict

    elif normalization_method.lower() == &#39;min-max&#39;:
        if columns_to_normalize is not False:
            mins = df[columns_to_normalize].min()
            maxs = df[columns_to_normalize].max()
            # Check if there are constant features
            const_feat = list(mins[mins == maxs].index)
            if len(const_feat) &gt; 0:
                # Prevent constant features from being normalized
                [columns_to_normalize.remove(col) for col in const_feat]
                mins = mins.drop(const_feat)
                maxs = maxs.drop(const_feat)
                warnings.warn(f&#39;Found columns {const_feat} to be constant throughout all the data. They should be removed as no insight will be extracted from them.&#39;)

            if isinstance(df, dd.DataFrame):
                # Make sure that the values are computed, in case we&#39;re using Dask
                mins = means.compute()
                maxs = maxs.compute()

        # Check if the data being normalized is directly the dataframe
        if data is None:
            if not inplace:
                # Make a copy of the data to avoid potentially unwanted changes to the original dataframe
                data = df.copy()
            else:
                # Use the original dataframe
                data = df

            if columns_to_normalize is not False:
                # Normalize the right columns
                print(f&#39;min-max normalizing columns {columns_to_normalize}...&#39;)
                data[columns_to_normalize] = (data[columns_to_normalize] - mins) / (maxs - mins)

            if columns_to_normalize_categ is not None:
                if get_stats is True:
                    min_list = []
                    max_list = []
                # Make sure that the columns_to_normalize_categ is a list
                if isinstance(columns_to_normalize_categ, tuple):
                    columns_to_normalize_categ = [columns_to_normalize_categ]
                if not isinstance(columns_to_normalize_categ, list):
                    raise Exception(f&#39;ERROR: The `columns_to_normalize_categ` argument must be specified as either a single tuple or a list of tuples. Received input with type {type(columns_to_normalize_categ)}.&#39;)
                print(f&#39;min-max normalizing columns {columns_to_normalize_categ} by their associated categories...&#39;)
                for col_tuple in columns_to_normalize_categ:
                    categ_columns = col_tuple[0]
                    column_to_normalize = col_tuple[1]
                    # Calculate the minimum and maximum values
                    mins_grpb = df.groupby(col_tuple[0])[col_tuple[1]].min()
                    maxs_grpb = df.groupby(col_tuple[0])[col_tuple[1]].max()
                    if isinstance(df, dd.DataFrame):
                        # Make sure that the values are computed, in case we&#39;re using Dask
                        mins_grpb = mins_grpb.compute()
                        maxs_grpb = maxs_grpb.compute()
                    if get_stats is True:
                        if isinstance(column_to_normalize, str):
                            # Make sure that the feature being normalized has its name specified in the stats
                            tmp_min_grpb = dict()
                            tmp_max_grpb = dict()
                            tmp_min_grpb[column_to_normalize] = mins_grpb.to_dict()
                            tmp_max_grpb[column_to_normalize] = maxs_grpb.to_dict()
                            # Add the current stats values to the output lists
                            min_list.append(tmp_min_grpb)
                            max_list.append(tmp_max_grpb)
                        else:
                            # Add the current stats values to the output lists
                            min_list.append(mins_grpb.to_dict())
                            max_list.append(maxs_grpb.to_dict())
                    # Get the categories columns as a numpy array, so as to
                    # index the groupby-resulting dataframes of minimum and
                    # maximum values
                    cat_arr = df[categ_columns].to_numpy()
                    if isinstance(categ_columns, list) and len(categ_columns) &gt; 1:
                        # Convert the sets of values into tuples so as to be
                        # properly readable as dataframe indices
                        cat_arr = list(map(tuple, cat_arr))
                    # Get the minimum and maximum values in the same
                    # order as the original dataframe&#39;s row order
                    mins_cat = mins_grpb.loc[cat_arr].to_numpy()
                    maxs_cat = maxs_grpb.loc[cat_arr].to_numpy()
                    # Normalize the right categories
                    data[column_to_normalize] = (data[column_to_normalize] - mins_cat) / (maxs_cat - mins_cat)
                if get_stats is True:
                    # Merge all the stats dictionaries
                    min_categ_dict = utils.merge_dicts(min_list)
                    max_categ_dict = utils.merge_dicts(max_list)
        # Otherwise, the tensor is normalized
        else:
            if columns_to_normalize is not False:
                # Dictionaries to retrieve the min and max values
                column_mins = dict(mins)
                column_maxs = dict(maxs)
                # Dictionary to convert the the tensor&#39;s column indices into the dataframe&#39;s column names
                idx_to_name = dict(enumerate(df.columns))
                # Dictionary to convert the dataframe&#39;s column names into the tensor&#39;s column indices
                name_to_idx = dict([(t[1], t[0]) for t in enumerate(df.columns)])
                # List of indices of the tensor&#39;s columns which are needing normalization
                tensor_columns_to_normalize = [name_to_idx[name] for name in columns_to_normalize]
                # Normalize the right columns
                print(f&#39;min-max normalizing columns {columns_to_normalize}...&#39;)
                for col in utils.iterations_loop(tensor_columns_to_normalize, see_progress=see_progress):
                    data[:, :, col] = ((data[:, :, col] - column_mins[idx_to_name[col]])
                                       / (column_maxs[idx_to_name[col]] - column_mins[idx_to_name[col]]))

        if get_stats is False:
            return data
        elif columns_to_normalize is not False and columns_to_normalize_categ is not None:
            return data, mins.to_dict(), maxs.to_dict(), min_categ_dict, max_categ_dict
        elif columns_to_normalize is not False and columns_to_normalize_categ is None:
            return data, mins.to_dict(), maxs.to_dict()
        elif columns_to_normalize is False and columns_to_normalize_categ is not None:
            return data, min_categ_dict, max_categ_dict
    else:
        raise ValueError(f&#39;{normalization_method} isn\&#39;t a valid normalization method. Available options \
                         are &#34;z-score&#34; and &#34;min-max&#34;.&#39;)


def denormalize_data(df=None, data=None, id_columns=[&#39;patientunitstayid&#39;, &#39;ts&#39;],
                     denormalization_method=&#39;z-score&#39;, columns_to_denormalize=None,
                     columns_to_denormalize_categ=None, categ_columns=None,
                     see_progress=True, search_by_dtypes=False, inplace=False,
                     means=None, stds=None, mins=None, maxs=None,
                     feature_columns=None):
    &#39;&#39;&#39;Performs data denormalization to a continuous valued tensor or dataframe,
       changing the scale of the data.

    Parameters
    ----------
    df : pandas.DataFrame or dask.DataFrame, default None
        Original Pandas or Dask dataframe which is used to correctly calculate the
        necessary statistical values used in the denormalization. These values
        can&#39;t be calculated from the tensor as it might have been padded. If
        the data tensor isn&#39;t specified, the denormalization is applied directly
        on the dataframe.
    data : torch.Tensor or numpy.Array, default None
        PyTorch tensor or NumPy array corresponding to the data which will be
        denormalized by the specified denormalization method. If the data isn&#39;t
        specified, the denormalization is applied directly on the dataframe.
    id_columns : string or list of strings, default [&#39;subject_id&#39;, &#39;ts&#39;]
        List of columns names which represent identifier columns. These are not
        supposed to be denormalized.
    denormalization_method : string, default &#39;z-score&#39;
        Specifies the denormalization method used. It can be a z-score
        denormalization, where the data is subtracted of its mean and divided
        by the standard deviation, which makes it have zero average and unit
        variance, much like a standard normal distribution; it can be a
        min-max denormalization, where the data is subtracted by its minimum
        value and then divided by the difference between the minimum and the
        maximum value, getting to a fixed range from 0 to 1.
    columns_to_denormalize : string or list of strings, default None
        If specified, the columns provided in the list are the only ones that
        will be denormalized. If set to False, no column will be denormalized directly,
        although columns can still be denormalized in groups of categories, if
        specified in the `columns_to_denormalize_categ` parameter. Otherwise, all
        continuous columns will be denormalized.
    columns_to_denormalize_categ : tuple or list of tuples of tuples, default None
        If specified, the columns provided in the list are going to be
        denormalized on their categories. That is, the values (column 2 in the
        tuple) are denormalized with stats of their respective categories (column
        1 of the tuple). Otherwise, no column will be denormalized on their
        categories.
    categ_columns : string or list of strings, default None
        If specified, the columns in the list, which represent categorical
        features, which either are a label or will be embedded, aren&#39;t
        going to be denormalized.
    see_progress : bool, default True
        If set to True, a progress bar will show up indicating the execution
        of the denormalization calculations.
    search_by_dtypes : bool, default False
        If set to True, the method will only look for boolean columns based on
        their data type. This is only reliable if all the columns&#39; data types
        have been properly set.
    inplace : bool, default False
        If set to True, the original dataframe will be used and modified
        directly. Otherwise, a copy will be created and returned, without
        changing the original dataframe.

    Returns
    -------
    data : pandas.DataFrame or dask.DataFrame or torch.Tensor
        Denormalized Pandas or Dask dataframe or PyTorch tensor.
    &#39;&#39;&#39;
    # [TODO] Add the option in denormalize_data to denormalize a data tensor
    # using a norm_stats dictionary instead of fetching the denormalization
    # stats from the original dataframe
    if feature_columns is None and df is not None:
        # List of all columns in the dataframe
        feature_columns = list(df.columns)
    # Check if specific columns have been specified for denormalization
    if columns_to_denormalize is None:
        # Denormalize all non identifier continuous columns, ignore one hot encoded ones
        columns_to_denormalize = feature_columns.copy()
        if id_columns is not None:
            # Make sure that the id_columns is a list
            if isinstance(id_columns, str):
                id_columns = [id_columns]
            if not isinstance(id_columns, list):
                raise Exception(f&#39;ERROR: The `id_columns` argument must be specified as either a single string or a list of strings. Received input with type {type(id_columns)}.&#39;)
            # List of all columns in the dataframe, except the ID columns
            [columns_to_denormalize.remove(col) for col in id_columns]
        if categ_columns is not None:
            # Make sure that the categ_columns is a list
            if isinstance(categ_columns, str):
                categ_columns = [categ_columns]
            if not isinstance(categ_columns, list):
                raise Exception(f&#39;ERROR: The `categ_columns` argument must be specified as either a single string or a list of strings. Received input with type {type(categ_columns)}.&#39;)
            # Prevent all features that will be embedded from being denormalized
            [columns_to_denormalize.remove(col) for col in categ_columns]
        # List of boolean or one hot encoded columns
        boolean_cols = search_explore.list_boolean_columns(df[columns_to_denormalize], search_by_dtypes=search_by_dtypes)
        if boolean_cols is not None:
            # Prevent boolean features from being denormalized
            [columns_to_denormalize.remove(col) for col in boolean_cols]
        # Remove all non numeric columns that could be left
        columns_to_denormalize = [col for col in columns_to_denormalize
                                if df[col].dtype == int or df[col].dtype == float]
        if columns_to_denormalize is None:
            print(&#39;No columns to denormalize, returning the original dataframe.&#39;)
            return df

    # Make sure that the columns_to_denormalize is a list
    if isinstance(columns_to_denormalize, str):
        columns_to_denormalize = [columns_to_denormalize]
    if not isinstance(columns_to_denormalize, list) and not isinstance(columns_to_denormalize, bool):
        raise Exception(f&#39;ERROR: The `columns_to_denormalize` argument must be specified as either a single string, a list of strings or a boolean. Received input with type {type(columns_to_denormalize)}.&#39;)

    if type(denormalization_method) is not str:
        raise ValueError(&#39;Argument denormalization_method should be a string. Available options are &#34;z-score&#34; and &#34;min-max&#34;.&#39;)

    if denormalization_method.lower() == &#39;z-score&#39;:
        if columns_to_denormalize is not False:
            # Calculate the means and standard deviations
            if means is None:
                means = df[columns_to_denormalize].mean()
            if stds is None:
                stds = df[columns_to_denormalize].std()
            # Check if there are constant features
            if isinstance(stds, pd.Series):
                const_feat = list(stds[stds == 0].index)
            elif isinstance(stds, dict):
                const_feat = [feat for feat in stds.keys() if stds[feat] == 0]
            if len(const_feat) &gt; 0:
                # Prevent constant features from being denormalized
                [columns_to_denormalize.remove(col) for col in const_feat]
                means = means.drop(const_feat)
                stds = stds.drop(const_feat)
                warnings.warn(f&#39;Found columns {const_feat} to be constant throughout all the data. They should be removed as no insight will be extracted from them.&#39;)

            if isinstance(df, dd.DataFrame):
                # Make sure that the values are computed, in case we&#39;re using Dask
                means = means.compute()
                stds = stds.compute()

        # Check if the data being denormalized is directly the dataframe
        if data is None:
            if not inplace:
                # Make a copy of the data to avoid potentially unwanted changes to the original dataframe
                data = df.copy()
            else:
                # Use the original dataframe
                data = df

            # Denormalize the right columns
            if columns_to_denormalize is not False:
                print(f&#39;z-score denormalizing columns {columns_to_denormalize}...&#39;)
                data[columns_to_denormalize] = data[columns_to_denormalize] * stds + means

            if columns_to_denormalize_categ is not None:
                # Make sure that the columns_to_denormalize_categ is a list
                if isinstance(columns_to_denormalize_categ, tuple):
                    columns_to_denormalize_categ = [columns_to_denormalize_categ]
                if not isinstance(columns_to_denormalize_categ, list):
                    raise Exception(f&#39;ERROR: The `columns_to_denormalize_categ` argument must be specified as either a single tuple or a list of tuples. Received input with type {type(columns_to_denormalize_categ)}.&#39;)
                print(f&#39;z-score denormalizing columns {columns_to_denormalize_categ} by their associated categories...&#39;)
                for col_tuple in utils.iterations_loop(columns_to_denormalize_categ, see_progress=see_progress):
                    categ_columns = col_tuple[0]
                    column_to_denormalize = col_tuple[1]
                    # Calculate the means and standard deviations
                    means_grpb = df.groupby(categ_columns)[
                        column_to_denormalize].mean()
                    stds_grpb = df.groupby(categ_columns)[
                        column_to_denormalize].std()
                    if isinstance(df, dd.DataFrame):
                        # Make sure that the values are computed, in case we&#39;re using Dask
                        means_grpb = means.compute()
                        stds_grpb = stds.compute()
                    # Get the categories columns as a numpy array, so as to
                    # index the groupby-resulting dataframes of mean and standard
                    # deviation values
                    cat_arr = df[categ_columns].to_numpy()
                    if isinstance(categ_columns, list) and len(categ_columns) &gt; 1:
                        # Convert the sets of values into tuples so as to be
                        # properly readable as dataframe indices
                        cat_arr = list(map(tuple, cat_arr))
                    # Get the mean and standard deviation values in the same
                    # order as the original dataframe&#39;s row order
                    means_cat = means_grpb.loc[cat_arr].to_numpy()
                    stds_cat = stds_grpb.loc[cat_arr].to_numpy()
                    # Denormalize the right categories
                    data[column_to_denormalize] = data[column_to_denormalize] * stds_cat + means_cat
        # Otherwise, the array is denormalized
        else:
            if not inplace:
                # Make a copy of the data to avoid potentially unwanted changes to the original array
                if isinstance(data, torch.Tensor):
                    data = data.clone()
                else:
                    data = data.copy()
            else:
                # Use the original array
                data = data
            if columns_to_denormalize is not False:
                # Dictionaries to retrieve the mean and standard deviation values
                if not isinstance(means, dict):
                    means = dict(means)
                if not isinstance(stds, dict):
                    stds = dict(stds)
                # Dictionary to convert the the array&#39;s column indices into the dataframe&#39;s column names
                idx_to_name = dict(enumerate(feature_columns))
                # Dictionary to convert the dataframe&#39;s column names into the array&#39;s column indices
                name_to_idx = dict([(t[1], t[0])
                                    for t in enumerate(feature_columns)])
                # List of indices of the array&#39;s columns which are needing denormalization
                array_columns_to_denormalize = [name_to_idx[name]
                                                for name in columns_to_denormalize]
                # Denormalize the right columns
                print(f&#39;z-score denormalizing columns {columns_to_denormalize}...&#39;)
                for col in utils.iterations_loop(array_columns_to_denormalize, see_progress=see_progress):
                    if len(data.shape) == 3:
                        data[:, :, col] = data[:, :, col] * stds[idx_to_name[col]] + means[idx_to_name[col]]
                    elif len(data.shape) == 2:
                        data[:, col] = data[:, col] * stds[idx_to_name[col]] + means[idx_to_name[col]]
                    else:
                        raise Exception(f&#39;ERROR: The data array or tensor must be either two or three-dimensional. The provided data has {len(data.shape)} dimensions.&#39;)

        return data

    elif denormalization_method.lower() == &#39;min-max&#39;:
        if columns_to_denormalize is not False:
            mins = df[columns_to_denormalize].min()
            maxs = df[columns_to_denormalize].max()
            # Check if there are constant features
            const_feat = list(mins[mins == maxs].index)
            if len(const_feat) &gt; 0:
                # Prevent constant features from being denormalized
                [columns_to_denormalize.remove(col) for col in const_feat]
                mins = mins.drop(const_feat)
                maxs = maxs.drop(const_feat)
                warnings.warn(f&#39;Found columns {const_feat} to be constant throughout all the data. They should be removed as no insight will be extracted from them.&#39;)

            if isinstance(df, dd.DataFrame):
                # Make sure that the values are computed, in case we&#39;re using Dask
                mins = means.compute()
                maxs = maxs.compute()

        # Check if the data being denormalized is directly the dataframe
        if data is None:
            if not inplace:
                # Make a copy of the data to avoid potentially unwanted changes to the original dataframe
                if isinstance(data, torch.Tensor):
                    data = data.clone()
                else:
                    data = data.copy()
            else:
                # Use the original dataframe
                data = df

            if columns_to_denormalize is not False:
                # Denormalize the right columns
                print(f&#39;min-max denormalizing columns {columns_to_denormalize}...&#39;)
                data[columns_to_denormalize] = data[columns_to_denormalize] * (maxs - mins) + mins

            if columns_to_denormalize_categ is not None:
                # Make sure that the columns_to_denormalize_categ is a list
                if isinstance(columns_to_denormalize_categ, tuple):
                    columns_to_denormalize_categ = [columns_to_denormalize_categ]
                if not isinstance(columns_to_denormalize_categ, list):
                    raise Exception(f&#39;ERROR: The `columns_to_denormalize_categ` argument must be specified as either a single tuple or a list of tuples. Received input with type {type(columns_to_denormalize_categ)}.&#39;)
                print(f&#39;min-max denormalizing columns {columns_to_denormalize_categ} by their associated categories...&#39;)
                for col_tuple in columns_to_denormalize_categ:
                    categ_columns = col_tuple[0]
                    column_to_denormalize = col_tuple[1]
                    # Calculate the minimum and maximum values
                    mins_grpb = df.groupby(col_tuple[0])[col_tuple[1]].min()
                    maxs_grpb = df.groupby(col_tuple[0])[col_tuple[1]].max()
                    if isinstance(df, dd.DataFrame):
                        # Make sure that the values are computed, in case we&#39;re using Dask
                        mins_grpb = mins_grpb.compute()
                        maxs_grpb = maxs_grpb.compute()
                    # Get the categories columns as a numpy array, so as to
                    # index the groupby-resulting dataframes of minimum and
                    # maximum values
                    cat_arr = df[categ_columns].to_numpy()
                    if isinstance(categ_columns, list) and len(categ_columns) &gt; 1:
                        # Convert the sets of values into tuples so as to be
                        # properly readable as dataframe indices
                        cat_arr = list(map(tuple, cat_arr))
                    # Get the minimum and maximum values in the same
                    # order as the original dataframe&#39;s row order
                    mins_cat = mins_grpb.loc[cat_arr].to_numpy()
                    maxs_cat = maxs_grpb.loc[cat_arr].to_numpy()
                    # Denormalize the right categories
                    data[column_to_denormalize] = data[column_to_denormalize] * (maxs_cat - mins_cat) + mins_cat
        # Otherwise, the array is denormalized
        else:
            if not inplace:
                # Make a copy of the data to avoid potentially unwanted changes to the original array
                data = data.clone()
            else:
                # Use the original array
                data = data
            if columns_to_denormalize is not False:
                # Dictionaries to retrieve the min and max values
                column_mins = dict(mins)
                column_maxs = dict(maxs)
                # Dictionary to convert the the array&#39;s column indices into the dataframe&#39;s column names
                idx_to_name = dict(enumerate(feature_columns))
                # Dictionary to convert the dataframe&#39;s column names into the array&#39;s column indices
                name_to_idx = dict([(t[1], t[0])
                                    for t in enumerate(feature_columns)])
                # List of indices of the array&#39;s columns which are needing denormalization
                array_columns_to_denormalize = [name_to_idx[name] for name in columns_to_denormalize]
                # Denormalize the right columns
                print(f&#39;min-max denormalizing columns {columns_to_denormalize}...&#39;)
                for col in utils.iterations_loop(array_columns_to_denormalize, see_progress=see_progress):
                    if len(data.shape) == 3:
                        data[:, :, col] = (data[:, :, col] * (column_maxs[idx_to_name[col]] - column_mins[idx_to_name[col]])
                                           + column_mins[idx_to_name[col]])
                    elif len(data.shape) == 2:
                        data[:, col] = (data[:, col] * (column_maxs[idx_to_name[col]] - column_mins[idx_to_name[col]])
                                        + column_mins[idx_to_name[col]])
                    else:
                        raise Exception(f&#39;ERROR: The data array or tensor must be either two or three-dimensional. The provided data has {len(data.shape)} dimensions.&#39;)

        return data
    else:
        raise ValueError(f&#39;{denormalization_method} isn\&#39;t a valid denormalization method. Available options \
                         are &#34;z-score&#34; and &#34;min-max&#34;.&#39;)


def transpose_dataframe(df, column_to_transpose=None, inplace=False):
    &#39;&#39;&#39;Transpose a dataframe, either by its original index or through a specific
    column, which will be converted to the new column names (i.e. the header).

    Parameters
    ----------
    data : pandas.DataFrame or dask.DataFrame
        Dataframe that will be transposed.
    column_to_transpose : string, default None
        If specified, the given column will be used as the new column names, with
        its unique values forming the new dataframe&#39;s header. Otherwise, the
        dataframe will be transposed on its original index.
    inplace : bool, default False
        If set to True, the original tensor or dataframe will be used and modified
        directly. Otherwise, a copy will be created and returned, without
        changing the original tensor or dataframe.

    Returns
    -------
    data : pandas.DataFrame or dask.DataFrame
        Transposed dataframe.
    &#39;&#39;&#39;
    if not inplace:
        # Make a copy of the data to avoid potentially unwanted changes to the original dataframe
        data_df = df.copy()
    else:
        # Use the original dataframe
        data_df = df
    if column_to_transpose is not None:
        # Set as index the column that has the desired column names as values
        data_df = data_df.set_index(column_to_transpose)
    if isinstance(data_df, pd.DataFrame):
        data_df = data_df.transpose()
    elif isinstance(data_df, dd.DataFrame):
        data_df = (dd.from_pandas(data_df.compute().transpose(),
                                  npartitions=data_df.npartitions))
    else:
        raise Exception(f&#39;ERROR: The input data must either be a Pandas dataframe or a Dask dataframe, not {type(df)}.&#39;)
    return data_df


def merge_values(x1, x2, separator=&#39;;&#39;, str_over_num=True, join_strings=True,
                 is_bool=False):
    &#39;&#39;&#39;Merge two values, by extracting the non-missing one, their average value
    or the non-numeric one.

    Parameters
    ----------
    x1
        Value 1 of the merge operation.
    x2
        Value 2 of the merge operation.
    separator : string, default &#39;;&#39;
        Symbol that concatenates each string&#39;s words, which will be used to join
        the inputs if they are both strings.
    str_over_num : bool, default True
        If set to True, preference will be given to string inputs. Otherwise,
        numeric inputs will be prioritized.
    join_strings : bool, default True
        If set to True, in case of receiving two string inputs, the algorithm
        will joined them using the defined separator. Otherwise, the shortest
        string will be returned.
    is_bool : bool, default False
        If set to True, the method will treat the values to merge as boolean
        (i.e. it will return either 1, if it&#39;s one of the values, or 0).

    Returns
    -------
    x
        Resulting merged value.
    &#39;&#39;&#39;
    if is_bool is True:
        if (x1 is None or utils.is_num_nan(x1)) and (x2 is None or utils.is_num_nan(x2)):
            return 0
        elif (x1 is None or utils.is_num_nan(x1)) and not (x2 is None or utils.is_num_nan(x2)):
            return x2
        elif not (x1 is None or utils.is_num_nan(x1)) and (x2 is None or utils.is_num_nan(x2)):
            return x1
        else:
            return max(x1, x2)
    if x1 is None and x2 is not None:
        return x2
    elif x1 is not None and x2 is None:
        return x1
    elif x1 == x2:
        return x1
    elif ((isinstance(x1, float) or isinstance(x1, int))
    and (isinstance(x2, float) or isinstance(x2, int))):
        # Get the average value between the columns, ignoring NaNs
        return np.nanmean([x1, x2])
    elif isinstance(x1, str) and isinstance(x2, str):
        if not isinstance(separator, str):
            raise Exception(f&#39;ERROR: Separator symbol must be in string format, not {type(separator)}.&#39;)
        if join_strings is True:
            # Join strings through the defined separator
            return separator.join([x1, x2])
        else:
            # Return the shortest string
            if len(x1) &lt;= len(x2):
                return x1
            else:
                return x2
    elif ((isinstance(x1, float) or isinstance(x1, int))
    and not (isinstance(x2, float) or isinstance(x2, int))):
        if utils.is_num_nan(x1) and not utils.is_num_nan(x2):
            # Return the not NaN value
            return x2
        if str_over_num is True:
            # Give preference to string values
            return x2
        else:
            # Give preference to numeric values
            return x1
    elif not ((isinstance(x1, float) or isinstance(x1, int))
    and (isinstance(x2, float) or isinstance(x2, int))):
        if utils.is_num_nan(x2) and not utils.is_num_nan(x1):
            # Return the not NaN value
            return x1
        if str_over_num is True:
            # Give preference to string values
            return x1
        else:
            # Give preference to numeric values
            return x2
    else:
        warnings.warn(f&#39;Both values are different than NaN and are not numeric. Randomly returning the first value {x1}, instead of {x2}.&#39;)
        return x1


def merge_columns(df, cols_to_merge=None, drop_old_cols=True, separator=&#39;;&#39;,
                  join_strings=False, see_progress=True, inplace=False):
    &#39;&#39;&#39;Merge columns that have been created, as a consequence of a dataframe
    merge operation, resulting in duplicate columns with suffixes.

    Parameters
    ----------
    df : pandas.DataFrame or dask.DataFrame
        Dataframe that will have its columns merged.
    cols_to_merge : string or list of strings, default None
        The columns which will be regenerated, by merging its duplicates.
        If not specified, the algorithm will search for columns with suffixes.
    drop_old_cols : bool, default True
        If set to True, the preexisting duplicate columns will be removed.
    separator : string, default &#39;;&#39;
        Symbol that concatenates each string&#39;s words, which will be used to join
        the inputs if they are both strings.
    join_strings : bool, default False
        If set to True, in case of receiving two string inputs, the algorithm
        will joined them using the defined separator. Otherwise, the shortest
        string will be returned.
    see_progress : bool, default True
        If set to True, a progress bar will show up indicating the execution
        of the normalization calculations.
    inplace : bool, default False
        If set to True, the original tensor or dataframe will be used and modified
        directly. Otherwise, a copy will be created and returned, without
        changing the original tensor or dataframe.

    Returns
    -------
    data_df : pandas.DataFrame or dask.DataFrame
        Dataframe with the new merged columns.
    &#39;&#39;&#39;
    if not inplace:
        # Make a copy of the data to avoid potentially unwanted changes to the original dataframe
        data_df = df.copy()
    else:
        # Use the original dataframe
        data_df = df
    if cols_to_merge is None:
        print(&#39;Finding columns to merge...&#39;)
        # Find all columns that have typical merging suffixes
        cols_to_merge = set([col.split(&#39;_x&#39;)[0].split(&#39;_y&#39;)[0] for col in df.columns
                             if col.endswith(&#39;_x&#39;) or col.endswith(&#39;_y&#39;)])
    # Make sure that the cols_to_merge is a list
    if isinstance(cols_to_merge, str):
        cols_to_merge = [cols_to_merge]
    print(&#39;Merging the duplicate columns...&#39;)
    for col in utils.iterations_loop(cols_to_merge, see_progress=see_progress):
        # Check if the columns being merged are boolean
        is_bool = all([search_explore.is_boolean_column(data_df, col, n_unique_values=None)]
                       for col in [f&#39;{col}_x&#39;, f&#39;{col}_y&#39;])
        # Create a column, with the original name, merging the associated columns&#39; values
        data_df[col] = data_df.apply(lambda x: merge_values(x[f&#39;{col}_x&#39;], x[f&#39;{col}_y&#39;],
                                                            separator=separator,
                                                            join_strings=join_strings,
                                                            is_bool=is_bool), axis=1)
    if drop_old_cols:
        print(&#39;Removing old columns...&#39;)
        # Remove the old columns, with suffixes `_x` and &#39;_y&#39;, which resulted
        # from the merge of dataframes
        for col in utils.iterations_loop(cols_to_merge, see_progress=see_progress):
            data_df = data_df.drop(columns=[f&#39;{col}_x&#39;, f&#39;{col}_y&#39;])
    print(&#39;Done!&#39;)
    return data_df


def missing_values_imputation(data, columns_to_imputate=None, method=&#39;zero&#39;,
                              id_column=None, zero_bool=True, reset_index=True,
                              search_by_dtypes=False, inplace=False):
    &#39;&#39;&#39;Performs missing values imputation to a tensor or dataframe corresponding to
    a single column.
    NOTE: Most imputation methods don&#39;t work with float16 data types and
    interpolation can&#39;t be applied to nullable integer types.

    Parameters
    ----------
    data : torch.Tensor or pandas.DataFrame or dask.DataFrame
        PyTorch tensor corresponding to a single column or a dataframe which will
        be imputed.
    columns_to_imputate : str or list of str, default None
        Specific column(s) to run missing values imputation on. Might be useful
        if some columns should be imputated in a specific method, different from
        the rest. If left unspecified, all columns will be imputated with the
        same method.
    method : string, default &#39;zero&#39;
        Imputation method to be used. If user inputs &#39;zero&#39;, it will just fill all
        missing values with zero. If the user chooses &#39;zigzag&#39;, it will do a
        forward fill, a backward fill and then replace all remaining missing values
        with zero (this option is only available for dataframes, not tensors).
        If the user selects &#39;interpolation&#39;, missing data will be interpolated based
        on known neighboring values and then all possible remaining ones are
        replaced with zero (this option is only available for dataframes, not
        tensors).
    id_column : string, default None
        Name of the column which corresponds to the sequence or subject identifier
        in the dataframe. If not specified, the imputation will not differenciate
        different IDs nor sequences. Only used if the chosen imputation method is
        &#39;zigzag&#39; or &#39;interpolation&#39;.
    zero_bool : bool, default True
        If set to True, it will look for boolean features and replace their
        missing values with zero, regardless of the chosen imputation method.
    reset_index : bool, default True
        If set to True (recommended), the dataframe&#39;s index will be reset. This
        can prevent values from being assigned to the wrong rows.
    search_by_dtypes : bool, default False
        If set to True, the method will only look for boolean columns based on
        their data type. This is only reliable if all the columns&#39; data types
        have been properly set.
    inplace : bool, default False
        If set to True, the original tensor or dataframe will be used and modified
        directly. Otherwise, a copy will be created and returned, without
        changing the original tensor or dataframe.

    Returns
    -------
    tensor : torch.Tensor
        Imputed PyTorch tensor.
    &#39;&#39;&#39;
    if ((not isinstance(data, pd.DataFrame))
         and (not isinstance(data, dd.DataFrame))
         and (not isinstance(data, torch.Tensor))):
        raise Exception(f&#39;ERROR: The input data must either be a PyTorch tensor, a Pandas dataframe or a Dask dataframe, not {type(data)}.&#39;)
    if not inplace:
        # Make a copy of the data to avoid potentially unwanted changes to the original data
        if isinstance(data, torch.Tensor):
            data_copy = data.clone()
        else:
            data_copy = data.copy()
    else:
        # Use the original data object
        data_copy = data
    # [TODO] Implement an option to only imputate specified column(s)
    # if columns is None:
    #     columns = list(data_copy.columns)
    if reset_index is True:
        # Reset index to avoid assigning values in the wrong rows
        print(&#39;Resetting the index...&#39;)
        data_copy.reset_index(drop=True, inplace=True)
    if columns_to_imputate is None:
        # Imputate all the columns
        columns_to_imputate = list(data_copy.columns)
    # Make sure that the columns_to_imputate is a list
    if isinstance(columns_to_imputate, str):
        columns_to_imputate = [columns_to_imputate]
    if id_column is not None:
        # Make sure that the ID column is in columns_to_imputate
        if id_column not in columns_to_imputate:
            columns_to_imputate = [id_column] + columns_to_imputate
    if zero_bool is True:
        # Check if there are boolean features
        print(&#39;Searching for boolean features...&#39;)
        bool_feat = search_explore.list_boolean_columns(data_copy, search_by_dtypes=search_by_dtypes)
        if len(bool_feat) &gt; 0:
            # Fill all boolean features&#39; missing values with zeros
            print(&#39;Replacing boolean features\&#39; missing values with zero...&#39;)
            data_copy.loc[:, bool_feat] = data_copy[bool_feat].fillna(value=0)
        # Remove the boolean columns from the list of columns to imputate
        columns_to_imputate = list(set(columns_to_imputate) - set(bool_feat))
    if method.lower() == &#39;zero&#39;:
        # Replace NaN&#39;s with zeros
        print(&#39;Replacing missing values with zero...&#39;)
        if isinstance(data, pd.DataFrame) or isinstance(data, dd.DataFrame):
            data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].fillna(value=0)
        elif isinstance(data, torch.Tensor):
            # [TODO] Add the ability to specify the tensor columns to imputate
            data_copy = torch.where(data_copy != data_copy, torch.zeros_like(data_copy), data_copy)
    elif method.lower() == &#39;zigzag&#39;:
        if isinstance(data, pd.DataFrame) or isinstance(data, dd.DataFrame):
            if id_column is not None:
                # Perform imputation on each ID separately
                # Forward fill and backward fill
                print(&#39;Forward filling and backward filling missing values...&#39;)
                data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].groupby(id_column).apply(lambda group: group.ffill().bfill())
                # Replace remaining missing values with zero
                print(&#39;Replacing remaining missing values with zero...&#39;)
                data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].fillna(value=0)
            else:
                # Apply imputation on all the data as one single sequence
                # Forward fill
                print(&#39;Forward filling missing values...&#39;)
                data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].ffill()
                # Backward fill
                print(&#39;Backward filling missing values...&#39;)
                data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].bfill()
                # Replace remaining missing values with zero
                print(&#39;Replacing remaining missing values with zero...&#39;)
                data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].fillna(value=0)
        elif isinstance(data, torch.Tensor):
            raise Exception(&#39;ERROR: PyTorch tensors aren\&#39;t supported in the zigzag imputation method. Please use a dataframe instead.&#39;)
    elif method.lower() == &#39;interpolation&#39;:
        if isinstance(data, pd.DataFrame) or isinstance(data, dd.DataFrame):
            # Linear interpolation, placing a linear scale between known points and doing simple
            # backward and forward fill, when the missing value doesn&#39;t have known data points
            # before or after, respectively
            # NOTE: Since the interpolate method doesn&#39;t work on nullable integer data types,
            # we need to find and separate columns with that dtype and apply zigzag imputation on them
            columns_cant_interpolate = list()
            for col in columns_to_imputate:
                if ((&#39;Int&#39; in str(data[col].dtype) or &#39;boolean&#39; in str(data[col].dtype))
                and col != id_column):
                    columns_cant_interpolate.append(col)
                    columns_to_imputate.remove(col)
            if id_column is not None:
                try:
                    if len(columns_cant_interpolate) &gt; 0:
                        # Perform zigzag imputation on columns that can&#39;t be interpolated
                        print(&#39;Running zigzag imputation on columns that can\&#39;t be interpolated...&#39;)
                        print(f&#39;(These columns are {columns_cant_interpolate})&#39;)
                        columns_cant_interpolate = [id_column] + columns_cant_interpolate
                        # Forward fill and backward fill
                        print(&#39;Forward filling and backward filling missing values...&#39;)
                        data_copy.loc[:, columns_cant_interpolate] = data_copy[columns_cant_interpolate].groupby(id_column).apply(lambda group: group.ffill().bfill())
                        # Replace remaining missing values with zero
                        print(&#39;Replacing remaining missing values with zero...&#39;)
                        data_copy.loc[:, columns_cant_interpolate] = data_copy[columns_cant_interpolate].fillna(value=0)
                    # There&#39;s no need to interpolate if the only column in columns_to_imputate is the ID column
                    if len(columns_to_imputate) &gt; 1:
                        # Perform imputation on each ID separately
                        print(&#39;Interpolating missing values...&#39;)
                        data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].groupby(id_column)[columns_to_imputate].apply(lambda group: group.interpolate(limit_direction=&#39;both&#39;))
                        # Replace remaining missing values with zero
                        print(&#39;Replacing remaining missing values with zero...&#39;)
                        data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].fillna(value=0)
                except ValueError as e:
                    warnings.warn(f&#39;Initial attempt to interpolate failed. Original exception message: &#34;{str(e)}&#34;\nTrying again after replacing all possible &lt;NA&gt; occurences with a Numpy NaN.&#39;)
                    # Save the current data types
                    dtype_dict = dict(data_copy.dtypes)
                    # Replace the &#39;&lt;NA&gt;&#39; objects with NumPy&#39;s NaN
                    data_copy = data_copy.applymap(lambda x: x if not utils.is_num_nan(x) else np.nan)
                    print(&#39;Finished replacing all possible &lt;NA&gt; values.&#39;)
                    # Perform imputation on each ID separately
                    print(&#39;Interpolating missing values...&#39;)
                    data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].groupby(id_column)[columns_to_imputate].apply(lambda group: group.interpolate(limit_direction=&#39;both&#39;))
                    # Replace remaining missing values with zero
                    print(&#39;Replacing remaining missing values with zero...&#39;)
                    data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].fillna(value=0)
                    # Convert the data types back to the original ones
                    print(&#39;Converting data types back to the original ones...&#39;)
                    data_copy = utils.convert_dtypes(data_copy, dtypes=dtype_dict, inplace=True)
            else:
                try:
                    if len(columns_cant_interpolate) &gt; 0:
                        # Perform zigzag imputation on columns that can&#39;t be interpolated
                        print(&#39;Running zigzag imputation on columns that can\&#39;t be interpolated...&#39;)
                        print(f&#39;(These columns are {columns_cant_interpolate})&#39;)
                        # Forward fill
                        print(&#39;Forward filling missing values...&#39;)
                        data_copy.loc[:, columns_cant_interpolate] = data_copy[columns_cant_interpolate].ffill()
                        # Backward fill
                        print(&#39;Backward filling missing values...&#39;)
                        data_copy.loc[:, columns_cant_interpolate] = data_copy[columns_cant_interpolate].bfill()
                        # Replace remaining missing values with zero
                        print(&#39;Replacing remaining missing values with zero...&#39;)
                        data_copy.loc[:, columns_cant_interpolate] = data_copy[columns_cant_interpolate].fillna(value=0)
                    # There&#39;s no need to interpolate if columns_to_imputate is empty
                    if len(columns_to_imputate) &gt; 0:
                        # Apply imputation on all the data as one single sequence
                        print(&#39;Interpolating missing values...&#39;)
                        data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].interpolate(limit_direction=&#39;both&#39;)
                        # Replace remaining missing values with zero
                        print(&#39;Replacing remaining missing values with zero...&#39;)
                        data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].fillna(value=0)
                except ValueError as e:
                    warnings.warn(f&#39;Initial attempt to interpolate failed. Original exception message: &#34;{str(e)}&#34;\nTrying again after replacing all possible &lt;NA&gt; occurences with a Numpy NaN.&#39;)
                    # Save the current data types
                    dtype_dict = dict(data_copy.dtypes)
                    data_copy = utils.convert_dtypes(data_copy, dtypes=dtype_dict, inplace=True)
                    print(&#39;Finished replacing all possible &lt;NA&gt; values.&#39;)
                    # Apply imputation on all the data as one single sequence
                    print(&#39;Interpolating missing values...&#39;)
                    data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].interpolate(limit_direction=&#39;both&#39;)
                    # Replace remaining missing values with zero
                    print(&#39;Replacing remaining missing values with zero...&#39;)
                    data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].fillna(value=0)
                    # Convert the data types back to the original ones
                    print(&#39;Converting data types back to the original ones...&#39;)
                    data_copy = utils.convert_dtypes(data_copy, dtypes=dtype_dict, inplace=True)
        elif isinstance(data, torch.Tensor):
            raise Exception(&#39;ERROR: PyTorch tensors aren\&#39;t supported in the interpolation imputation method. Please use a dataframe instead.&#39;)
    else:
        raise Exception(f&#39;ERROR: Unsupported {method} imputation method. Currently available options are `zero` and `zigzag`.&#39;)
    # [TODO] Add other, more complex imputation methods, like a denoising autoencoder
    print(&#39;Done!&#39;)
    return data_copy


def __sep_dosage_units(x):
    # Start by assuming that dosage and unit are unknown
    dosage = np.nan
    unit = np.nan
    try:
        x = x.split(&#39; &#39;)
        if len(x) == 2:
            try:
                # Add correctly formated dosage
                dosage = float(x[0])
            except Exception:
                pass
            try:
                if utils.is_definitely_string(x[1]):
                    # Add correctly formated unit values
                    unit = x[1]
            except Exception:
                pass
        elif len(x) == 1:
            try:
                # Try to add correctly formated dosage, even without units
                dosage = float(x[0])
            except Exception:
                pass
    except Exception:
        try:
            # Try to add correctly formated dosage, even without units
            dosage = float(x)
        except:
            pass
    return dosage, unit


def set_dosage_and_units(df, orig_column=&#39;dosage&#39;, new_column_names=[&#39;drug_dosage&#39;, &#39;drug_unit&#39;]):
    &#39;&#39;&#39;Separate medication dosage string column into numeric dosage and units
    features.

    Parameters
    ----------
    df : pandas.DataFrame or dask.DataFrame
        Dataframe containing the medication dosage information.
    orig_column : string, default &#39;dosage&#39;
        Name of the original column, which will be split in two.

    Returns
    -------
    df : pandas.DataFrame or dask.DataFrame
        Dataframe after adding the numeric dosage and units columns.
    &#39;&#39;&#39;
    # Separate the dosage and unit data
    dosage_unit_data = df[orig_column].apply(__sep_dosage_units)
    # Make sure that the new columns are created
    for col in new_column_names:
        df[col] = np.nan
    # Add the new dosage and units columns
    df[new_column_names] = pd.DataFrame(dosage_unit_data.to_numpy().tolist(),
                                        index=dosage_unit_data.index)
    return df


def signal_idx_derivative(s, time_scale=&#39;seconds&#39;, periods=1):
    &#39;&#39;&#39;Creates a series that contains the signal&#39;s index derivative, with the
    same divisions (if needed) as the original data and on the desired time
    scale.

    Parameters
    ----------
    s : pandas.Series or dask.Series
        Series which will be analyzed for outlier detection.
    time_scale : bool, default &#39;seconds&#39;
        How to calculate derivatives, either with respect to the index values,
        on the time scale of &#39;seconds&#39;, &#39;minutes&#39;, &#39;hours&#39;, &#39;days&#39;, &#39;months&#39; or
        &#39;years&#39;, or just sequentially, just getting the difference between
        consecutive values, &#39;False&#39;. Only used if parameter &#39;signal&#39; isn&#39;t set
        to &#39;value&#39;.
    periods : int, default 1
        Defines the steps to take when calculating the derivative. When set to 1,
        it performs a normal backwards derivative. When set to 1, it performs a
        normal forwards derivative.

    Returns
    -------
    s_idx : pandas.Series or dask.Series
        Index derivative signal, on the desired time scale.
    &#39;&#39;&#39;
    # Calculate the signal index&#39;s derivative
    s_idx = s.index.to_series().diff()
    if isinstance(s_idx, dd.DataFrame):
        # Make the new derivative have the same divisions as the original signal
        s_idx = (s_idx.to_frame().rename(columns={s.index.name:&#39;tmp_val&#39;})
                      .reset_index()
                      .set_index(s.index.name, sorted=True, divisions=s.divisions)
                      .tmp_val)
    # Convert derivative to the desired time scale
    if time_scale == &#39;seconds&#39;:
        s_idx = s_idx.dt.seconds
    elif time_scale == &#39;minutes&#39;:
        s_idx = s_idx.dt.seconds / 60
    elif time_scale == &#39;hours&#39;:
        s_idx = s_idx.dt.seconds / 3600
    elif time_scale == &#39;days&#39;:
        s_idx = s_idx.dt.seconds / 86400
    elif time_scale == &#39;months&#39;:
        s_idx = s_idx.dt.seconds / 2592000
    return s_idx


def threshold_outlier_detect(s, max_thrs=None, min_thrs=None, threshold_type=&#39;absolute&#39;,
                             signal_type=&#39;value&#39;, time_scale=&#39;seconds&#39;,
                             derivate_direction=&#39;backwards&#39;):
    &#39;&#39;&#39;Detects outliers based on predetermined thresholds.

    Parameters
    ----------
    s : pandas.Series or dask.Series
        Series which will be analyzed for outlier detection.
    max_thrs : int or float, default None
        Maximum threshold, i.e. no normal value can be larger than this
        threshold, in the signal (or its n-order derivative) that we&#39;re
        analyzing.
    min_thrs : int or float, default None
        Minimum threshold, i.e. no normal value can be smaller than this
        threshold, in the signal (or its n-order derivative) that we&#39;re
        analyzing.
    threshold_type : string, default &#39;absolute&#39;
        Determines if we&#39;re using threshold values with respect to the original
        scale of values, &#39;absolute&#39;, relative to the signal&#39;s mean, &#39;mean&#39; or
        &#39;average&#39;, to the median, &#39;median&#39; or to the standard deviation, &#39;std&#39;.
        As such, the possible settings are [&#39;absolute&#39;, &#39;mean&#39;, &#39;average&#39;,
        &#39;median&#39;, &#39;std&#39;].
    signal_type : string, default &#39;value&#39;
        Sets if we&#39;re analyzing the original signal value, &#39;value&#39;, its first
        derivative, &#39;derivative&#39; or &#39;speed&#39;, or its second derivative, &#39;second
        derivative&#39; or &#39;acceleration&#39;. As such, the possible settings are
        [&#39;value&#39;, &#39;derivative&#39;, &#39;speed&#39;, &#39;second derivative&#39;, &#39;acceleration&#39;].
    time_scale : string or bool, default &#39;seconds&#39;
        How to calculate derivatives, either with respect to the index values,
        on the time scale of &#39;seconds&#39;, &#39;minutes&#39;, &#39;hours&#39;, &#39;days&#39;, &#39;months&#39; or
        &#39;years&#39;, or just sequentially, just getting the difference between
        consecutive values, &#39;False&#39;. Only used if parameter &#39;signal&#39; isn&#39;t set
        to &#39;value&#39;.
    derivate_direction : string, default &#39;backwards&#39;
        The direction in which we calculate the derivative, either comparing to
        previous values, &#39;backwards&#39;, or to the next values, &#39;forwards&#39;. As such,
        the possible settings are [&#39;backwards&#39;, &#39;forwards&#39;]. Only used if
        parameter &#39;signal&#39; isn&#39;t set to &#39;value&#39;.

    Returns
    -------
    outlier_s : pandas.Series or dask.Series
        Boolean series indicating where the detected outliers are.
    &#39;&#39;&#39;
    if signal_type.lower() == &#39;value&#39;:
        signal = s
    elif signal_type.lower() == &#39;derivative&#39; or signal_type.lower() == &#39;speed&#39;:
        if derivate_direction.lower() == &#39;backwards&#39;:
            periods = 1
        elif derivate_direction.lower() == &#39;forwards&#39;:
            periods = -1
        else:
            raise Exception(f&#39;ERROR: Invalid derivative direction. It must either be &#34;backwards&#34; or &#34;forwards&#34;, not {derivate_direction}.&#39;)
        # Calculate the difference between consecutive values
        signal = s.diff(periods)
        if time_scale is not None:
            # Derivate by the index values
            signal = signal / signal_idx_derivative(signal, time_scale, periods)
    elif (signal_type.lower() == &#39;second derivative&#39;
          or signal_type.lower() == &#39;acceleration&#39;):
        if derivate_direction.lower() == &#39;backwards&#39;:
            periods = 1
        elif derivate_direction.lower() == &#39;forwards&#39;:
            periods = -1
        else:
            raise Exception(f&#39;ERROR: Invalid derivative direction. It must either be &#34;backwards&#34; or &#34;forwards&#34;, not {derivate_direction}.&#39;)
        # Calculate the difference between consecutive values
        signal = s.diff(periods).diff(periods)
        if time_scale is not None:
            # Derivate by the index values
            signal = signal / signal_idx_derivative(signal, time_scale, periods)
    else:
        raise Exception(&#39;ERROR: Invalid signal type. It must be &#34;value&#34;, &#34;derivative&#34;, &#34;speed&#34;, &#34;second derivative&#34; or &#34;acceleration&#34;, not {signal}.&#39;)
    if threshold_type.lower() == &#39;absolute&#39;:
        signal = signal
    elif threshold_type.lower() == &#39;mean&#39; or threshold_type.lower() == &#39;average&#39;:
        signal_mean = signal.mean()
        if isinstance(signal, dd.DataFrame):
            # Make sure that the value is computed, in case we&#39;re using Dask
            signal_mean = signal_mean.compute()
        # Normalize by the average value
        signal = signal / signal_mean
    elif threshold_type.lower() == &#39;median&#39;:
        if isinstance(signal, dd.DataFrame):
            # Make sure that the value is computed, in case we&#39;re using Dask
            signal_median = signal.compute().median()
        else:
            signal_median = signal.median()
        # Normalize by the median value
        signal = signal / signal_median
    elif threshold_type.lower() == &#39;std&#39;:
        signal_mean = signal.mean()
        signal_std = signal.std()
        if isinstance(signal, dd.DataFrame):
            # Make sure that the values are computed, in case we&#39;re using Dask
            signal_mean = signal_mean.compute()
            signal_std = signal_std.compute()
        # Normalize by the average and standard deviation values
        signal = (signal - signal_mean) / signal_std
    else:
        raise Exception(f&#39;ERROR: Invalid value type. It must be &#34;absolute&#34;, &#34;mean&#34;, &#34;average&#34;, &#34;median&#34; or &#34;std&#34;, not {threshold_type}.&#39;)

    # Search for outliers based on the given thresholds
    if max_thrs is not None and min_thrs is not None:
        outlier_s = (signal &gt; max_thrs) | (signal &lt; min_thrs)
    elif max_thrs is not None:
        outlier_s = signal &gt; max_thrs
    elif min_thrs is not None:
        outlier_s = signal &lt; min_thrs
    else:
        raise Exception(&#39;ERROR: At least a maximum or a minimum threshold must be set. Otherwise, no outlier will ever be detected.&#39;)

    return outlier_s


def slopes_outlier_detect(s, max_thrs=4, bidir_sens=0.5, threshold_type=&#39;std&#39;,
                          time_scale=&#39;seconds&#39;, only_bir=False):
    &#39;&#39;&#39;Detects outliers based on large variations on the signal&#39;s derivatives,
    either in one direction or on both at the same time.

    Parameters
    ----------
    s : pandas.Series or dask.Series
        Series which will be analyzed for outlier detection.
    max_thrs : int or float
        Maximum threshold, i.e. no point can have a magnitude derivative value
        deviate more than this threshold, in the signal that we&#39;re analyzing.
    bidir_sens : float, default 0.5
        Dictates how much more sensitive the algorithm is when a deviation (i.e.
        large variation) is found on both sides of the data point / both
        directions of the derivative. In other words, it&#39;s a factor that will be
        multiplied by the usual one-directional threshold (`max_thrs`), from which
        the resulting value will be used as the bidirectional threshold.
    threshold_type : string, default &#39;std&#39;
        Determines if we&#39;re using threshold values with respect to the original
        scale of derivative values, &#39;absolute&#39;, relative to the derivative&#39;s
        mean, &#39;mean&#39; or &#39;average&#39;, to the median, &#39;median&#39; or to the standard
        deviation, &#39;std&#39;. As such, the possible settings are [&#39;absolute&#39;, &#39;mean&#39;,
        &#39;average&#39;, &#39;median&#39;, &#39;std&#39;].
    time_scale : string or bool, default &#39;seconds&#39;
        How to calculate derivatives, either with respect to the index values,
        on the time scale of &#39;seconds&#39;, &#39;minutes&#39;, &#39;hours&#39;, &#39;days&#39;, &#39;months&#39; or
        &#39;years&#39;, or just sequentially, just getting the difference between
        consecutive values, &#39;False&#39;. Only used if parameter &#39;signal&#39; isn&#39;t set
        to &#39;value&#39;.
    only_bir : bool, default False
        If set to True, the algorithm will only check for data points that have
        large derivatives on both directions.

    Returns
    -------
    outlier_s : pandas.Series or dask.Series
        Boolean series indicating where the detected outliers are.
    &#39;&#39;&#39;
    # Calculate the difference between consecutive values
    bckwrds_deriv = s.diff()
    frwrds_deriv = s.diff(-1)
    if time_scale is not None:
        # Derivate by the index values
        bckwrds_deriv = bckwrds_deriv / signal_idx_derivative(bckwrds_deriv, time_scale, periods=1)
        frwrds_deriv = frwrds_deriv / signal_idx_derivative(frwrds_deriv, time_scale, periods=-1)
    if threshold_type.lower() == &#39;absolute&#39;:
        bckwrds_deriv = bckwrds_deriv
        frwrds_deriv = frwrds_deriv
    elif threshold_type.lower() == &#39;mean&#39; or threshold_type.lower() == &#39;average&#39;:
        bckwrds_deriv_mean = bckwrds_deriv.mean()
        frwrds_deriv_mean = frwrds_deriv.mean()
        if isinstance(bckwrds_deriv, dd.DataFrame):
            # Make sure that the value is computed, in case we&#39;re using Dask
            bckwrds_deriv_mean = bckwrds_deriv_mean.compute()
            frwrds_deriv_mean = frwrds_deriv_mean.compute()
        # Normalize by the average value
        bckwrds_deriv = bckwrds_deriv / bckwrds_deriv_mean
        frwrds_deriv = frwrds_deriv / frwrds_deriv_mean
    elif threshold_type.lower() == &#39;median&#39;:
        bckwrds_deriv_median = bckwrds_deriv.median()
        frwrds_deriv_median = frwrds_deriv.median()
        if isinstance(bckwrds_deriv, dd.DataFrame):
            # Make sure that the value is computed, in case we&#39;re using Dask
            bckwrds_deriv_median = bckwrds_deriv_median.compute()
            frwrds_deriv_median = frwrds_deriv_median.compute()
        # Normalize by the median value
        bckwrds_deriv = bckwrds_deriv / bckwrds_deriv_median
        frwrds_deriv = frwrds_deriv / frwrds_deriv_median
    elif threshold_type.lower() == &#39;std&#39;:
        bckwrds_deriv_mean = bckwrds_deriv.mean()
        frwrds_deriv_mean = frwrds_deriv.mean()
        bckwrds_deriv_std = bckwrds_deriv.std()
        frwrds_deriv_std = frwrds_deriv.std()
        if isinstance(bckwrds_deriv, dd.DataFrame):
            # Make sure that the values are computed, in case we&#39;re using Dask
            bckwrds_deriv_mean = bckwrds_deriv_mean.compute()
            frwrds_deriv_mean = frwrds_deriv_mean.compute()
            bckwrds_deriv_std = bckwrds_deriv_std.compute()
            frwrds_deriv_std = frwrds_deriv_std.compute()
        # Normalize by the average and standard deviation values
        bckwrds_deriv = (bckwrds_deriv - bckwrds_deriv_mean) / bckwrds_deriv_std
        frwrds_deriv = (frwrds_deriv - frwrds_deriv_mean) / frwrds_deriv_std
    else:
        raise Exception(&#39;ERROR: Invalid value type. It must be &#34;absolute&#34;, &#34;mean&#34;, &#34;average&#34;, &#34;median&#34; or &#34;std&#34;, not {threshold_type}.&#39;)

    # Bidirectional threshold, to be used when observing both directions of the derivative
    bidir_max = bidir_sens * max_thrs
    if only_bir is True:
        # Search for outliers on both derivatives at the same time, always on their respective magnitudes
        outlier_s = (bckwrds_deriv.abs() &gt; bidir_max) &amp; (frwrds_deriv.abs() &gt; bidir_max)
    else:
        # Search for outliers on each individual derivative, followed by both at the same time with a lower threshold, always on their respective magnitudes
        outlier_s = ((bckwrds_deriv.abs() &gt; max_thrs) | (frwrds_deriv.abs() &gt; max_thrs)
                     | ((bckwrds_deriv.abs() &gt; bidir_max) &amp; (frwrds_deriv.abs() &gt; bidir_max)))
    return outlier_s


def save_chunked_data(df, file_name, n_chunks=None, batch_size=1,
                      id_column=None, data_path=&#39;&#39;, format=&#39;feather&#39;):
    &#39;&#39;&#39;Save a dataframe in chunks, i.e. in separate files, so as to prevent
    memory issues and other problems when loading it back again.

    Parameters
    ----------
    df : pandas.DataFrame or dask.DataFrame
        Dataframe which will be saved in chunks.
    file_name : str
        Name to be given to the file.
    n_chunks : int, default None
        Number of chunks, i.e. number of files, on which to split and save the
        dataframe.
    batch_size : int, default 1
        Defines the batch size, i.e. the number of samples used in each
        training iteration to update the model&#39;s weights.
    id_column : string, default None
        Name of the column which corresponds to the sequence or subject identifier
        in the dataframe. If specified, the data will be saved in files
        containing a `batch_size` number of unique IDs. This is useful if we&#39;re
        working with large datasets, which therefore need to be loaded file by
        file, lazily, in each training or inference batch.
    data_path : str, default &#39;&#39;
        Directory path where the file will be stored.
    format : str, default &#39;feather&#39;
        Data format used to saved the dataframe. Currently available options are
        &#39;feather&#39;.
    &#39;&#39;&#39;
    n_rows = len(df)
    format = str(format).lower()
    if format == &#39;feather&#39;:
        file_ext = &#39;.ftr&#39;
    else:
        raise Exception(f&#39;ERROR: Invalid data format &#34;{format}&#34;. Please choose one of the currently supported formats &#34;feather&#34;.&#39;)
    if n_chunks is not None:
        # Total number of rows per file
        chunk_size = int(n_rows / n_chunks)
        for i in du.utils.iterations_loop(range(n_chunks)):
            # Get a chunk of the dataframe
            if i &lt; n_chunks-1:
                df_i = df.iloc[i*chunk_size:(i+1)*chunk_size]
            else:
                df_i = df.iloc[i*chunk_size:]
            # Reset the index, so as to make it feather compatible
            df_i.reset_index(drop=True, inplace=True)
            # Save the current dataframe
            df_i.to_feather(f&#39;{data_path}{file_name}_{i}{file_ext}&#39;)
            # Remove the already saved dataframe from memory
            del df_i
    elif batch_size is not None and id_column is not None:
        # List of unique sequence identifiers
        ids = list(df[id_column].unique())
        # Number of unique IDs
        n_ids = len(ids)
        # Total number of files to be saved
        n_chunks = max(1, math.ceil(n_ids / batch_size))
        for i in du.utils.iterations_loop(range(n_chunks)):
            # Set the current batch&#39;s list of IDs
            if i &lt; n_chunks-1:
                ids_i = ids[i*batch_size:(i+1)*batch_size]
            else:
                ids_i = ids[i*batch_size:]
            # Get a chunk of the dataframe
            df_i = df[df[id_column].isin(ids_i)]
            # Reset the index, so as to make it feather compatible
            df_i.reset_index(drop=True, inplace=True)
            # Save the current dataframe
            df_i.to_feather(f&#39;{data_path}{file_name}_{i}{file_ext}&#39;)
            # Remove the already saved dataframe from memory
            del df_i
    else:
        raise Exception(f&#39;ERROR: Invalid set of input parameters. The user must either specify a number of chunks (`n_chunks`) to save the data or a batch size (`batch_size`) and an ID column (`id_column`) on which to fetch sequences.&#39;)


def load_chunked_data(file_name, n_chunks=None, data_path=&#39;&#39;, format=&#39;feather&#39;,
                      dtypes=None, ordered_naming=True):
    &#39;&#39;&#39;Load a dataframe in chunks, i.e. in separate files, so as to prevent
    memory issues and other problems when loading.

    Parameters
    ----------
    file_name : str
        Name of the file where the dataframe is saved.
    n_chunks : int, default None
        Number of chunks, i.e. number of files, needed to load the dataframe.
        If left unspecified, all the files that match the naming and format will
        be loaded.
    data_path : str, default &#39;&#39;
        Directory path where the file is stored.
    format : str, default &#39;feather&#39;
        Data format used to saved the dataframe. Currently available options are
        &#39;feather&#39;.
    dtypes : dict, default None
        Dictionary that indicates the desired dtype for each column.
        e.g. {&#39;Var1&#39;: &#39;float64&#39;, &#39;Var2&#39;: &#39;UInt8&#39;, &#39;Var3&#39;: str}
    ordered_naming : bool, default True
        If set to True, the method will load data considering an ordered naming,
        staring in 0 until n_chunks. Otherwise, it will search for all files
        that have the specified naming and format, even if it uses a different
        or irregular numbering.

    Returns
    -------
    df : pandas.DataFrame or dask.DataFrame
        Loaded dataframe.
    &#39;&#39;&#39;
    # Validate the file format
    format = str(format).lower()
    if format == &#39;feather&#39;:
        file_ext = &#39;.ftr&#39;
    else:
        raise Exception(f&#39;ERROR: Invalid data format &#34;{format}&#34;. Please choose one of the currently supported formats &#34;feather&#34;.&#39;)
    if n_chunks is None or ordered_naming is False:
        # Get a list with the names of the files that can be loaded
        data_files = glob(f&#39;{data_path}{file_name}_*{file_ext}&#39;)
        if n_chunks is None:
            # Load all the files, if no limit is specified
            n_chunks = len(data_files)
    for i in du.utils.iterations_loop(range(n_chunks)):
        if i == 0:
            # Load the first file
            if ordered_naming is True:
                df = pd.read_feather(f&#39;{data_path}{file_name}_{i}{file_ext}&#39;)
            else:
                df = pd.read_feather(data_files[i])
            if dtypes is not None:
                df = du.utils.convert_dtypes(df, dtypes=dtypes, inplace=True)
        else:
            # Load another file and join it with the already loaded ones
            if ordered_naming is True:
                tmp_df = pd.read_feather(f&#39;{data_path}{file_name}_{i}{file_ext}&#39;)
            else:
                tmp_df = pd.read_feather(data_files[i])
            if dtypes is not None:
                tmp_df = du.utils.convert_dtypes(tmp_df, dtypes=dtypes, inplace=True)
            df = pd.concat((df, tmp_df))
            # Remove the already concatenated dataframe from memory
            del tmp_df
    return df</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="data_utils.data_processing.apply_minmax_denorm"><code class="name flex">
<span>def <span class="ident">apply_minmax_denorm</span></span>(<span>value, df=None, min=None, max=None, categories_mins=None, categories_maxs=None, groupby_columns=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs minmax denormalization when used inside a Pandas or Dask
apply function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Input normalized value.</dd>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code>, default <code>None</code></dt>
<dd>Original pandas dataframe which is used to retrieve the
necessary statistical values used in group denormalization, i.e. when
values are denormalized according to their corresponding categories.</dd>
<dt><strong><code>min</code></strong> :&ensp;<code>int</code> or <code>float</code>, default <code>None</code></dt>
<dd>Minimum value to be used in the minmax denormalization.</dd>
<dt><strong><code>max</code></strong> :&ensp;<code>int</code> or <code>float</code>, default <code>None</code></dt>
<dd>Maximum value to be used in the minmax denormalization.</dd>
<dt><strong><code>categories_mins</code></strong> :&ensp;<code>dict</code>, default <code>None</code></dt>
<dd>Dictionary containing the minimum values for each set of categories.</dd>
<dt><strong><code>categories_maxs</code></strong> :&ensp;<code>dict</code>, default <code>None</code></dt>
<dd>Dictionary containing the maximum values for each set of categories.</dd>
<dt><strong><code>groupby_columns</code></strong> :&ensp;<code>string</code> or <code>list</code> of <code>strings</code>, default <code>None</code></dt>
<dd>Name(s) of the column(s) that contains the categories from which
statistical values (minimum and maximum) are retrieved.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value_denorm</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Minmax denormalized value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_minmax_denorm(value, df=None, min=None, max=None, categories_mins=None,
                      categories_maxs=None, groupby_columns=None):
    &#39;&#39;&#39;Performs minmax denormalization when used inside a Pandas or Dask
    apply function.

    Parameters
    ----------
    value : int or float
        Input normalized value.
    df : pandas.DataFrame or dask.DataFrame, default None
        Original pandas dataframe which is used to retrieve the
        necessary statistical values used in group denormalization, i.e. when
        values are denormalized according to their corresponding categories.
    min : int or float, default None
        Minimum value to be used in the minmax denormalization.
    max : int or float, default None
        Maximum value to be used in the minmax denormalization.
    categories_mins : dict, default None
        Dictionary containing the minimum values for each set of categories.
    categories_maxs : dict, default None
        Dictionary containing the maximum values for each set of categories.
    groupby_columns : string or list of strings, default None
        Name(s) of the column(s) that contains the categories from which
        statistical values (minimum and maximum) are retrieved.

    Returns
    -------
    value_denorm : int or float
        Minmax denormalized value.
    &#39;&#39;&#39;
    if not isinstance(value, numbers.Number):
        raise Exception(f&#39;ERROR: Input value should be a number, not an object of type {type(value)}.&#39;)
    if min is not None and max is not None:
        return value * (max - min) + min
    elif (df is not None and categories_mins is not None
          and categories_maxs is not None and groupby_columns is not None):
        try:
            if isinstance(groupby_columns, list):
                return (value * (categories_maxs[tuple(df[groupby_columns])]
                        - categories_mins[tuple(df[groupby_columns])])
                        + categories_mins[tuple(df[groupby_columns])])
            else:
                return (value * (categories_maxs[df[groupby_columns]]
                        - categories_mins[df[groupby_columns]])
                        + categories_mins[df[groupby_columns]])
        except Exception:
            warnings.warn(f&#39;Couldn\&#39;t manage to find the mean and standard deviation values for the groupby columns {groupby_columns} with values {tuple(df[groupby_columns])}.&#39;)
            return np.nan
    else:
        raise Exception(&#39;ERROR: Invalid parameters. Either the `min` and `max` or the `df`, `categories_mins`, `categories_maxs` and `groupby_columns` must be set.&#39;)</code></pre>
</details>
</dd>
<dt id="data_utils.data_processing.apply_minmax_norm"><code class="name flex">
<span>def <span class="ident">apply_minmax_norm</span></span>(<span>value, df=None, min=None, max=None, categories_mins=None, categories_maxs=None, groupby_columns=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs minmax normalization when used inside a Pandas or Dask
apply function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Original, unnormalized value.</dd>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code>, default <code>None</code></dt>
<dd>Original pandas dataframe which is used to retrieve the
necessary statistical values used in group normalization, i.e. when
values are normalized according to their corresponding categories.</dd>
<dt><strong><code>min</code></strong> :&ensp;<code>int</code> or <code>float</code>, default <code>None</code></dt>
<dd>Minimum value to be used in the minmax normalization.</dd>
<dt><strong><code>max</code></strong> :&ensp;<code>int</code> or <code>float</code>, default <code>None</code></dt>
<dd>Maximum value to be used in the minmax normalization.</dd>
<dt><strong><code>categories_mins</code></strong> :&ensp;<code>dict</code>, default <code>None</code></dt>
<dd>Dictionary containing the minimum values for each set of categories.</dd>
<dt><strong><code>categories_maxs</code></strong> :&ensp;<code>dict</code>, default <code>None</code></dt>
<dd>Dictionary containing the maximum values for each set of categories.</dd>
<dt><strong><code>groupby_columns</code></strong> :&ensp;<code>string</code> or <code>list</code> of <code>strings</code>, default <code>None</code></dt>
<dd>Name(s) of the column(s) that contains the categories from which
statistical values (minimum and maximum) are retrieved.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value_norm</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Minmax normalized value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_minmax_norm(value, df=None, min=None, max=None, categories_mins=None,
                      categories_maxs=None, groupby_columns=None):
    &#39;&#39;&#39;Performs minmax normalization when used inside a Pandas or Dask
    apply function.

    Parameters
    ----------
    value : int or float
        Original, unnormalized value.
    df : pandas.DataFrame or dask.DataFrame, default None
        Original pandas dataframe which is used to retrieve the
        necessary statistical values used in group normalization, i.e. when
        values are normalized according to their corresponding categories.
    min : int or float, default None
        Minimum value to be used in the minmax normalization.
    max : int or float, default None
        Maximum value to be used in the minmax normalization.
    categories_mins : dict, default None
        Dictionary containing the minimum values for each set of categories.
    categories_maxs : dict, default None
        Dictionary containing the maximum values for each set of categories.
    groupby_columns : string or list of strings, default None
        Name(s) of the column(s) that contains the categories from which
        statistical values (minimum and maximum) are retrieved.

    Returns
    -------
    value_norm : int or float
        Minmax normalized value.
    &#39;&#39;&#39;
    if not isinstance(value, numbers.Number):
        raise Exception(f&#39;ERROR: Input value should be a number, not an object of type {type(value)}.&#39;)
    if min and max:
        return (value - min) / (max - min)
    elif df and categories_mins and categories_maxs and groupby_columns:
        try:
            if isinstance(groupby_columns, list):
                return ((value - categories_mins[tuple(df[groupby_columns])])
                        / (categories_maxs[tuple(df[groupby_columns])] - categories_mins[tuple(df[groupby_columns])]))
            else:
                return ((value - categories_mins[df[groupby_columns]])
                        / (categories_maxs[df[groupby_columns]] - categories_mins[df[groupby_columns]]))
        except Exception:
            warnings.warn(f&#39;Couldn\&#39;t manage to find the mean and standard deviation values for the groupby columns {groupby_columns} with values {tuple(df[groupby_columns])}.&#39;)
            return np.nan
    else:
        raise Exception(&#39;ERROR: Invalid parameters. Either the `min` and `max` or the `df`, `categories_mins`, `categories_maxs` and `groupby_columns` must be set.&#39;)</code></pre>
</details>
</dd>
<dt id="data_utils.data_processing.apply_zscore_denorm"><code class="name flex">
<span>def <span class="ident">apply_zscore_denorm</span></span>(<span>value, df=None, mean=None, std=None, categories_means=None, categories_stds=None, groupby_columns=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs z-score denormalization when used inside a Pandas or Dask
apply function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Input normalized value.</dd>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code>, default <code>None</code></dt>
<dd>Original pandas dataframe which is used to retrieve the
necessary statistical values used in group denormalization, i.e. when
values are denormalized according to their corresponding categories.</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code>int</code> or <code>float</code>, default <code>None</code></dt>
<dd>Average (mean) value to be used in the z-score denormalization.</dd>
<dt><strong><code>std</code></strong> :&ensp;<code>int</code> or <code>float</code>, default <code>None</code></dt>
<dd>Standard deviation value to be used in the z-score denormalization.</dd>
<dt><strong><code>categories_means</code></strong> :&ensp;<code>dict</code>, default <code>None</code></dt>
<dd>Dictionary containing the average values for each set of categories.</dd>
<dt><strong><code>categories_stds</code></strong> :&ensp;<code>dict</code>, default <code>None</code></dt>
<dd>Dictionary containing the standard deviation values for each set of
categories.</dd>
<dt><strong><code>groupby_columns</code></strong> :&ensp;<code>string</code> or <code>list</code> of <code>strings</code>, default <code>None</code></dt>
<dd>Name(s) of the column(s) that contains the categories from which
statistical values (mean and standard deviation) are retrieved.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value_denorm</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Z-score denormalized value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_zscore_denorm(value, df=None, mean=None, std=None, categories_means=None,
                      categories_stds=None, groupby_columns=None):
    &#39;&#39;&#39;Performs z-score denormalization when used inside a Pandas or Dask
    apply function.

    Parameters
    ----------
    value : int or float
        Input normalized value.
    df : pandas.DataFrame or dask.DataFrame, default None
        Original pandas dataframe which is used to retrieve the
        necessary statistical values used in group denormalization, i.e. when
        values are denormalized according to their corresponding categories.
    mean : int or float, default None
        Average (mean) value to be used in the z-score denormalization.
    std : int or float, default None
        Standard deviation value to be used in the z-score denormalization.
    categories_means : dict, default None
        Dictionary containing the average values for each set of categories.
    categories_stds : dict, default None
        Dictionary containing the standard deviation values for each set of
        categories.
    groupby_columns : string or list of strings, default None
        Name(s) of the column(s) that contains the categories from which
        statistical values (mean and standard deviation) are retrieved.

    Returns
    -------
    value_denorm : int or float
        Z-score denormalized value.
    &#39;&#39;&#39;
    if not isinstance(value, numbers.Number):
        raise Exception(f&#39;ERROR: Input value should be a number, not an object of type {type(value)}.&#39;)
    if mean is not None and std is not None:
        return value * std + mean
    elif (df is not None and categories_means is not None
          and categories_stds is not None and groupby_columns is not None):
        try:
            if isinstance(groupby_columns, list):
                return (value * categories_stds[tuple(df[groupby_columns])]
                        + categories_means[tuple(df[groupby_columns])])
            else:
                return (value * categories_stds[df[groupby_columns]]
                        + categories_means[df[groupby_columns]])
        except Exception:
            warnings.warn(f&#39;Couldn\&#39;t manage to find the mean and standard deviation values for the groupby columns {groupby_columns} with values {tuple(df[groupby_columns])}.&#39;)
            return np.nan
    else:
        raise Exception(&#39;ERROR: Invalid parameters. Either the `mean` and `std` or the `df`, `categories_means`, `categories_stds` and `groupby_columns` must be set.&#39;)</code></pre>
</details>
</dd>
<dt id="data_utils.data_processing.apply_zscore_norm"><code class="name flex">
<span>def <span class="ident">apply_zscore_norm</span></span>(<span>value, df=None, mean=None, std=None, categories_means=None, categories_stds=None, groupby_columns=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs z-score normalization when used inside a Pandas or Dask
apply function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Original, unnormalized value.</dd>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code>, default <code>None</code></dt>
<dd>Original pandas dataframe which is used to retrieve the
necessary statistical values used in group normalization, i.e. when
values are normalized according to their corresponding categories.</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code>int</code> or <code>float</code>, default <code>None</code></dt>
<dd>Average (mean) value to be used in the z-score normalization.</dd>
<dt><strong><code>std</code></strong> :&ensp;<code>int</code> or <code>float</code>, default <code>None</code></dt>
<dd>Standard deviation value to be used in the z-score normalization.</dd>
<dt><strong><code>categories_means</code></strong> :&ensp;<code>dict</code>, default <code>None</code></dt>
<dd>Dictionary containing the average values for each set of categories.</dd>
<dt><strong><code>categories_stds</code></strong> :&ensp;<code>dict</code>, default <code>None</code></dt>
<dd>Dictionary containing the standard deviation values for each set of
categories.</dd>
<dt><strong><code>groupby_columns</code></strong> :&ensp;<code>string</code> or <code>list</code> of <code>strings</code>, default <code>None</code></dt>
<dd>Name(s) of the column(s) that contains the categories from which
statistical values (mean and standard deviation) are retrieved.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>value_norm</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Z-score normalized value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_zscore_norm(value, df=None, mean=None, std=None, categories_means=None,
                      categories_stds=None, groupby_columns=None):
    &#39;&#39;&#39;Performs z-score normalization when used inside a Pandas or Dask
    apply function.

    Parameters
    ----------
    value : int or float
        Original, unnormalized value.
    df : pandas.DataFrame or dask.DataFrame, default None
        Original pandas dataframe which is used to retrieve the
        necessary statistical values used in group normalization, i.e. when
        values are normalized according to their corresponding categories.
    mean : int or float, default None
        Average (mean) value to be used in the z-score normalization.
    std : int or float, default None
        Standard deviation value to be used in the z-score normalization.
    categories_means : dict, default None
        Dictionary containing the average values for each set of categories.
    categories_stds : dict, default None
        Dictionary containing the standard deviation values for each set of
        categories.
    groupby_columns : string or list of strings, default None
        Name(s) of the column(s) that contains the categories from which
        statistical values (mean and standard deviation) are retrieved.

    Returns
    -------
    value_norm : int or float
        Z-score normalized value.
    &#39;&#39;&#39;
    if not isinstance(value, numbers.Number):
        raise Exception(f&#39;ERROR: Input value should be a number, not an object of type {type(value)}.&#39;)
    if mean is not None and std is not None:
        return (value - mean) / std
    elif (df is not None and categories_means is not None
          and categories_stds is not None and groupby_columns is not None):
        try:
            if isinstance(groupby_columns, list):
                return ((value - categories_means[tuple(df[groupby_columns])])
                        / categories_stds[tuple(df[groupby_columns])])
            else:
                return ((value - categories_means[df[groupby_columns]])
                        / categories_stds[df[groupby_columns]])
        except Exception:
            warnings.warn(f&#39;Couldn\&#39;t manage to find the mean and standard deviation values for the groupby columns {groupby_columns} with values {tuple(df[groupby_columns])}.&#39;)
            return np.nan
    else:
        raise Exception(&#39;ERROR: Invalid parameters. Either the `mean` and `std` or the `df`, `categories_means`, `categories_stds` and `groupby_columns` must be set.&#39;)</code></pre>
</details>
</dd>
<dt id="data_utils.data_processing.category_to_feature"><code class="name flex">
<span>def <span class="ident">category_to_feature</span></span>(<span>df, categories_feature, values_feature, min_len=None, see_progress=True, inplace=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a categorical column and its corresponding values column into
new features, one for each category.
WARNING: Currently not working properly on a Dask dataframe. Apply .compute()
to the dataframe to convert it to Pandas, before passing it to this method.
If the data is too big to run on Pandas, use the category_to_feature_big_data
method.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code></dt>
<dd>Dataframe on which to add the new features.</dd>
<dt><strong><code>categories_feature</code></strong> :&ensp;<code>string</code></dt>
<dd>Name of the feature that contains the categories that will be converted
to individual features.</dd>
<dt><strong><code>values_feature</code></strong> :&ensp;<code>string</code></dt>
<dd>Name of the feature that has each category's corresponding value, which
may or may not be a category on its own (e.g. it could be numeric values).</dd>
<dt><strong><code>min_len</code></strong> :&ensp;<code>int</code>, default <code>None</code></dt>
<dd>If defined, only the categories that appear on at least <code>min_len</code> rows
are converted to features.</dd>
<dt><strong><code>see_progress</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, a progress bar will show up indicating the execution
of the normalization calculations.</dd>
<dt><strong><code>inplace</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, the original dataframe will be used and modified
directly. Otherwise, a copy will be created and returned, without
changing the original dataframe.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data_df</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code></dt>
<dd>Dataframe with the newly created features.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def category_to_feature(df, categories_feature, values_feature, min_len=None,
                        see_progress=True, inplace=False):
    &#39;&#39;&#39;Convert a categorical column and its corresponding values column into
    new features, one for each category.
    WARNING: Currently not working properly on a Dask dataframe. Apply .compute()
    to the dataframe to convert it to Pandas, before passing it to this method.
    If the data is too big to run on Pandas, use the category_to_feature_big_data
    method.

    Parameters
    ----------
    df : pandas.DataFrame or dask.DataFrame
        Dataframe on which to add the new features.
    categories_feature : string
        Name of the feature that contains the categories that will be converted
        to individual features.
    values_feature : string
        Name of the feature that has each category&#39;s corresponding value, which
        may or may not be a category on its own (e.g. it could be numeric values).
    min_len : int, default None
        If defined, only the categories that appear on at least `min_len` rows
        are converted to features.
    see_progress : bool, default True
        If set to True, a progress bar will show up indicating the execution
        of the normalization calculations.
    inplace : bool, default False
        If set to True, the original dataframe will be used and modified
        directly. Otherwise, a copy will be created and returned, without
        changing the original dataframe.

    Returns
    -------
    data_df : pandas.DataFrame or dask.DataFrame
        Dataframe with the newly created features.
    &#39;&#39;&#39;
    if not inplace:
        # Make a copy of the data to avoid potentially unwanted changes to the original dataframe
        data_df = df.copy()
    else:
        # Use the original dataframe
        data_df = df
    # Find the unique categories
    categories = data_df[categories_feature].unique()
    if isinstance(df, dd.DataFrame):
        categories = categories.compute()
    # Create a feature for each category
    for category in utils.iterations_loop(categories, see_progress=see_progress):
        if min_len is not None:
            # Check if the current category has enough data to be worth it to convert to a feature
            if len(data_df[data_df[categories_feature] == category]) &lt; min_len:
                # Ignore the current category
                continue
        # Convert category to feature
        data_df[category] = data_df.apply(lambda x: x[values_feature] if x[categories_feature] == category
                                                    else np.nan, axis=1)
    return data_df</code></pre>
</details>
</dd>
<dt id="data_utils.data_processing.category_to_feature_big_data"><code class="name flex">
<span>def <span class="ident">category_to_feature_big_data</span></span>(<span>df, categories_feature, values_feature, min_len=None, see_progress=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a categorical column and its corresponding values column into
new features, one for each category. Optimized for very big Dask dataframes,
which can't be processed as a whole Pandas dataframe.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>dask.DataFrame</code></dt>
<dd>Dataframe on which to add the new features.</dd>
<dt><strong><code>categories_feature</code></strong> :&ensp;<code>string</code></dt>
<dd>Name of the feature that contains the categories that will be converted
to individual features.</dd>
<dt><strong><code>values_feature</code></strong> :&ensp;<code>string</code></dt>
<dd>Name of the feature that has each category's corresponding value, which
may or may not be a category on its own (e.g. it could be numeric values).</dd>
<dt><strong><code>min_len</code></strong> :&ensp;<code>int</code>, default <code>None</code></dt>
<dd>If defined, only the categories that appear on at least <code>min_len</code> rows
are converted to features.</dd>
<dt><strong><code>see_progress</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, a progress bar will show up indicating the execution
of the normalization calculations.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data_df</code></strong> :&ensp;<code>dask.DataFrame</code></dt>
<dd>Dataframe with the newly created features.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def category_to_feature_big_data(df, categories_feature, values_feature,
                                 min_len=None, see_progress=True):
    &#39;&#39;&#39;Convert a categorical column and its corresponding values column into
    new features, one for each category. Optimized for very big Dask dataframes,
    which can&#39;t be processed as a whole Pandas dataframe.

    Parameters
    ----------
    df : dask.DataFrame
        Dataframe on which to add the new features.
    categories_feature : string
        Name of the feature that contains the categories that will be converted
        to individual features.
    values_feature : string
        Name of the feature that has each category&#39;s corresponding value, which
        may or may not be a category on its own (e.g. it could be numeric values).
    min_len : int, default None
        If defined, only the categories that appear on at least `min_len` rows
        are converted to features.
    see_progress : bool, default True
        If set to True, a progress bar will show up indicating the execution
        of the normalization calculations.

    Returns
    -------
    data_df : dask.DataFrame
        Dataframe with the newly created features.
    &#39;&#39;&#39;
    # Create a list with Pandas dataframe versions of each partition of the
    # original Dask dataframe
    df_list = []
    print(&#39;Converting categories to features in each partition...&#39;)
    for n in utils.iterations_loop(range(df.npartitions), see_progress=see_progress):
        # Process each partition separately in Pandas
        tmp_df = df.get_partition(n).compute()
        tmp_df = category_to_feature(tmp_df, categories_feature=categories_feature,
                                     values_feature=values_feature, min_len=min_len,
                                     see_progress=see_progress)
        df_list.append(tmp_df)
    # Rejoin all the partitions into a Dask dataframe with the same number of
    # partitions it originally had
    print(&#39;Rejoining partitions into a Dask dataframe...&#39;)
    data_df = dd.from_pandas(pd.concat(df_list, sort=False), npartitions=df.npartitions)
    print(&#39;Done!&#39;)
    return data_df</code></pre>
</details>
</dd>
<dt id="data_utils.data_processing.clean_categories_naming"><code class="name flex">
<span>def <span class="ident">clean_categories_naming</span></span>(<span>df, column, clean_missing_values=True, specific_nan_strings=[], lower_case=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Change categorical values to only have lower case letters and underscores.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code></dt>
<dd>Dataframe that contains the column to be cleaned.</dd>
<dt><strong><code>column</code></strong> :&ensp;<code>string</code></dt>
<dd>Name of the dataframe's column which needs to have its string values
standardized.</dd>
<dt><strong><code>clean_missing_values</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, the algorithm will search for missing value
representations and replace them with the standard, NumPy NaN value.</dd>
<dt><strong><code>specific_nan_strings</code></strong> :&ensp;<code>list</code> of <code>strings</code>, default <code>[]</code></dt>
<dd>Parameter where the user can specify additional strings that
should correspond to missing values.</dd>
<dt><strong><code>lower_case</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, all strings will be converted to lower case.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code></dt>
<dd>Dataframe with its string column already cleaned.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_categories_naming(df, column, clean_missing_values=True,
                            specific_nan_strings=[], lower_case=False):
    &#39;&#39;&#39;Change categorical values to only have lower case letters and underscores.

    Parameters
    ----------
    df : pandas.DataFrame or dask.DataFrame
        Dataframe that contains the column to be cleaned.
    column : string
        Name of the dataframe&#39;s column which needs to have its string values
        standardized.
    clean_missing_values : bool, default True
        If set to True, the algorithm will search for missing value
        representations and replace them with the standard, NumPy NaN value.
    specific_nan_strings : list of strings, default []
        Parameter where the user can specify additional strings that
        should correspond to missing values.
    lower_case : bool, default False
        If set to True, all strings will be converted to lower case.

    Returns
    -------
    df : pandas.DataFrame or dask.DataFrame
        Dataframe with its string column already cleaned.
    &#39;&#39;&#39;
    # Fix the seeting of all lower case characters according to the `lower_case` parameter
    clean_naming_prtl = partial(clean_naming, lower_case=lower_case)
    if isinstance(df, dd.DataFrame):
        df[column] = (df[column].map(clean_naming_prtl, meta=(&#39;x&#39;, str)))
        if clean_missing_values is True:
            df[column] = df[column].apply(lambda x: standardize_missing_values(x, specific_nan_strings),
                                          meta=df[column]._meta.dtypes)
    else:
        df[column] = (df[column].map(clean_naming_prtl))
        if clean_missing_values is True:
            df[column] = df[column].apply(lambda x: standardize_missing_values(x, specific_nan_strings))
    return df</code></pre>
</details>
</dd>
<dt id="data_utils.data_processing.clean_naming"><code class="name flex">
<span>def <span class="ident">clean_naming</span></span>(<span>x, lower_case=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Change strings to only have lower case letters and underscores.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>string</code> or <code>list</code> of <code>strings</code></dt>
<dd>String(s) on which to clean the naming, standardizing it.</dd>
<dt><strong><code>lower_case</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, all strings will be converted to lower case.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>string</code> or <code>list</code> of <code>strings</code></dt>
<dd>Cleaned string(s).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_naming(x, lower_case=True):
    &#39;&#39;&#39;Change strings to only have lower case letters and underscores.

    Parameters
    ----------
    x : string or list of strings
        String(s) on which to clean the naming, standardizing it.
    lower_case : bool, default True
        If set to True, all strings will be converted to lower case.

    Returns
    -------
    x : string or list of strings
        Cleaned string(s).
    &#39;&#39;&#39;
    if &#39;pandas.core.indexes.base.Index&#39; in str(type(x)):
        # If the user input is a dataframe index (e.g. df.columns), convert it to a list
        x = list(x)
    if isinstance(x, list):
        if lower_case is True:
            x = [string.lower().replace(&#39;  &#39;, &#39;&#39;)
                               .replace(&#39; &#39;, &#39;_&#39;)
                               .replace(&#39;,&#39;, &#39;_and&#39;) for string in x]
        else:
            x = [string.replace(&#39;  &#39;, &#39;&#39;)
                       .replace(&#39; &#39;, &#39;_&#39;)
                       .replace(&#39;,&#39;, &#39;_and&#39;) for string in x]
    elif (isinstance(x, pd.DataFrame)
    or isinstance(x, pd.Series)
    or isinstance(x, dd.DataFrame)
    or isinstance(x, dd.Series)):
        raise Exception(&#39;ERROR: Wrong method. When using dataframes or series, use clean_categories_naming() method instead.&#39;)
    else:
        if lower_case is True:
            x = (str(x).lower().replace(&#39;  &#39;, &#39;&#39;)
                               .replace(&#39; &#39;, &#39;_&#39;)
                               .replace(&#39;,&#39;, &#39;_and&#39;))
        else:
            x = (str(x).replace(&#39;  &#39;, &#39;&#39;)
                       .replace(&#39; &#39;, &#39;_&#39;)
                       .replace(&#39;,&#39;, &#39;_and&#39;))
    return x</code></pre>
</details>
</dd>
<dt id="data_utils.data_processing.denormalize_data"><code class="name flex">
<span>def <span class="ident">denormalize_data</span></span>(<span>df=None, data=None, id_columns=['patientunitstayid', 'ts'], denormalization_method='z-score', columns_to_denormalize=None, columns_to_denormalize_categ=None, categ_columns=None, see_progress=True, search_by_dtypes=False, inplace=False, means=None, stds=None, mins=None, maxs=None, feature_columns=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs data denormalization to a continuous valued tensor or dataframe,
changing the scale of the data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code>, default <code>None</code></dt>
<dd>Original Pandas or Dask dataframe which is used to correctly calculate the
necessary statistical values used in the denormalization. These values
can't be calculated from the tensor as it might have been padded. If
the data tensor isn't specified, the denormalization is applied directly
on the dataframe.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>torch.Tensor</code> or <code>numpy.Array</code>, default <code>None</code></dt>
<dd>PyTorch tensor or NumPy array corresponding to the data which will be
denormalized by the specified denormalization method. If the data isn't
specified, the denormalization is applied directly on the dataframe.</dd>
<dt><strong><code>id_columns</code></strong> :&ensp;<code>string</code> or <code>list</code> of <code>strings</code>, default <code>['subject_id', 'ts']</code></dt>
<dd>List of columns names which represent identifier columns. These are not
supposed to be denormalized.</dd>
<dt><strong><code>denormalization_method</code></strong> :&ensp;<code>string</code>, default <code>'z-score'</code></dt>
<dd>Specifies the denormalization method used. It can be a z-score
denormalization, where the data is subtracted of its mean and divided
by the standard deviation, which makes it have zero average and unit
variance, much like a standard normal distribution; it can be a
min-max denormalization, where the data is subtracted by its minimum
value and then divided by the difference between the minimum and the
maximum value, getting to a fixed range from 0 to 1.</dd>
<dt><strong><code>columns_to_denormalize</code></strong> :&ensp;<code>string</code> or <code>list</code> of <code>strings</code>, default <code>None</code></dt>
<dd>If specified, the columns provided in the list are the only ones that
will be denormalized. If set to False, no column will be denormalized directly,
although columns can still be denormalized in groups of categories, if
specified in the <code>columns_to_denormalize_categ</code> parameter. Otherwise, all
continuous columns will be denormalized.</dd>
<dt><strong><code>columns_to_denormalize_categ</code></strong> :&ensp;<code>tuple</code> or <code>list</code> of <code>tuples</code> of <code>tuples</code>, default <code>None</code></dt>
<dd>If specified, the columns provided in the list are going to be
denormalized on their categories. That is, the values (column 2 in the
tuple) are denormalized with stats of their respective categories (column
1 of the tuple). Otherwise, no column will be denormalized on their
categories.</dd>
<dt><strong><code>categ_columns</code></strong> :&ensp;<code>string</code> or <code>list</code> of <code>strings</code>, default <code>None</code></dt>
<dd>If specified, the columns in the list, which represent categorical
features, which either are a label or will be embedded, aren't
going to be denormalized.</dd>
<dt><strong><code>see_progress</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, a progress bar will show up indicating the execution
of the denormalization calculations.</dd>
<dt><strong><code>search_by_dtypes</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, the method will only look for boolean columns based on
their data type. This is only reliable if all the columns' data types
have been properly set.</dd>
<dt><strong><code>inplace</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, the original dataframe will be used and modified
directly. Otherwise, a copy will be created and returned, without
changing the original dataframe.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code> or <code>torch.Tensor</code></dt>
<dd>Denormalized Pandas or Dask dataframe or PyTorch tensor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def denormalize_data(df=None, data=None, id_columns=[&#39;patientunitstayid&#39;, &#39;ts&#39;],
                     denormalization_method=&#39;z-score&#39;, columns_to_denormalize=None,
                     columns_to_denormalize_categ=None, categ_columns=None,
                     see_progress=True, search_by_dtypes=False, inplace=False,
                     means=None, stds=None, mins=None, maxs=None,
                     feature_columns=None):
    &#39;&#39;&#39;Performs data denormalization to a continuous valued tensor or dataframe,
       changing the scale of the data.

    Parameters
    ----------
    df : pandas.DataFrame or dask.DataFrame, default None
        Original Pandas or Dask dataframe which is used to correctly calculate the
        necessary statistical values used in the denormalization. These values
        can&#39;t be calculated from the tensor as it might have been padded. If
        the data tensor isn&#39;t specified, the denormalization is applied directly
        on the dataframe.
    data : torch.Tensor or numpy.Array, default None
        PyTorch tensor or NumPy array corresponding to the data which will be
        denormalized by the specified denormalization method. If the data isn&#39;t
        specified, the denormalization is applied directly on the dataframe.
    id_columns : string or list of strings, default [&#39;subject_id&#39;, &#39;ts&#39;]
        List of columns names which represent identifier columns. These are not
        supposed to be denormalized.
    denormalization_method : string, default &#39;z-score&#39;
        Specifies the denormalization method used. It can be a z-score
        denormalization, where the data is subtracted of its mean and divided
        by the standard deviation, which makes it have zero average and unit
        variance, much like a standard normal distribution; it can be a
        min-max denormalization, where the data is subtracted by its minimum
        value and then divided by the difference between the minimum and the
        maximum value, getting to a fixed range from 0 to 1.
    columns_to_denormalize : string or list of strings, default None
        If specified, the columns provided in the list are the only ones that
        will be denormalized. If set to False, no column will be denormalized directly,
        although columns can still be denormalized in groups of categories, if
        specified in the `columns_to_denormalize_categ` parameter. Otherwise, all
        continuous columns will be denormalized.
    columns_to_denormalize_categ : tuple or list of tuples of tuples, default None
        If specified, the columns provided in the list are going to be
        denormalized on their categories. That is, the values (column 2 in the
        tuple) are denormalized with stats of their respective categories (column
        1 of the tuple). Otherwise, no column will be denormalized on their
        categories.
    categ_columns : string or list of strings, default None
        If specified, the columns in the list, which represent categorical
        features, which either are a label or will be embedded, aren&#39;t
        going to be denormalized.
    see_progress : bool, default True
        If set to True, a progress bar will show up indicating the execution
        of the denormalization calculations.
    search_by_dtypes : bool, default False
        If set to True, the method will only look for boolean columns based on
        their data type. This is only reliable if all the columns&#39; data types
        have been properly set.
    inplace : bool, default False
        If set to True, the original dataframe will be used and modified
        directly. Otherwise, a copy will be created and returned, without
        changing the original dataframe.

    Returns
    -------
    data : pandas.DataFrame or dask.DataFrame or torch.Tensor
        Denormalized Pandas or Dask dataframe or PyTorch tensor.
    &#39;&#39;&#39;
    # [TODO] Add the option in denormalize_data to denormalize a data tensor
    # using a norm_stats dictionary instead of fetching the denormalization
    # stats from the original dataframe
    if feature_columns is None and df is not None:
        # List of all columns in the dataframe
        feature_columns = list(df.columns)
    # Check if specific columns have been specified for denormalization
    if columns_to_denormalize is None:
        # Denormalize all non identifier continuous columns, ignore one hot encoded ones
        columns_to_denormalize = feature_columns.copy()
        if id_columns is not None:
            # Make sure that the id_columns is a list
            if isinstance(id_columns, str):
                id_columns = [id_columns]
            if not isinstance(id_columns, list):
                raise Exception(f&#39;ERROR: The `id_columns` argument must be specified as either a single string or a list of strings. Received input with type {type(id_columns)}.&#39;)
            # List of all columns in the dataframe, except the ID columns
            [columns_to_denormalize.remove(col) for col in id_columns]
        if categ_columns is not None:
            # Make sure that the categ_columns is a list
            if isinstance(categ_columns, str):
                categ_columns = [categ_columns]
            if not isinstance(categ_columns, list):
                raise Exception(f&#39;ERROR: The `categ_columns` argument must be specified as either a single string or a list of strings. Received input with type {type(categ_columns)}.&#39;)
            # Prevent all features that will be embedded from being denormalized
            [columns_to_denormalize.remove(col) for col in categ_columns]
        # List of boolean or one hot encoded columns
        boolean_cols = search_explore.list_boolean_columns(df[columns_to_denormalize], search_by_dtypes=search_by_dtypes)
        if boolean_cols is not None:
            # Prevent boolean features from being denormalized
            [columns_to_denormalize.remove(col) for col in boolean_cols]
        # Remove all non numeric columns that could be left
        columns_to_denormalize = [col for col in columns_to_denormalize
                                if df[col].dtype == int or df[col].dtype == float]
        if columns_to_denormalize is None:
            print(&#39;No columns to denormalize, returning the original dataframe.&#39;)
            return df

    # Make sure that the columns_to_denormalize is a list
    if isinstance(columns_to_denormalize, str):
        columns_to_denormalize = [columns_to_denormalize]
    if not isinstance(columns_to_denormalize, list) and not isinstance(columns_to_denormalize, bool):
        raise Exception(f&#39;ERROR: The `columns_to_denormalize` argument must be specified as either a single string, a list of strings or a boolean. Received input with type {type(columns_to_denormalize)}.&#39;)

    if type(denormalization_method) is not str:
        raise ValueError(&#39;Argument denormalization_method should be a string. Available options are &#34;z-score&#34; and &#34;min-max&#34;.&#39;)

    if denormalization_method.lower() == &#39;z-score&#39;:
        if columns_to_denormalize is not False:
            # Calculate the means and standard deviations
            if means is None:
                means = df[columns_to_denormalize].mean()
            if stds is None:
                stds = df[columns_to_denormalize].std()
            # Check if there are constant features
            if isinstance(stds, pd.Series):
                const_feat = list(stds[stds == 0].index)
            elif isinstance(stds, dict):
                const_feat = [feat for feat in stds.keys() if stds[feat] == 0]
            if len(const_feat) &gt; 0:
                # Prevent constant features from being denormalized
                [columns_to_denormalize.remove(col) for col in const_feat]
                means = means.drop(const_feat)
                stds = stds.drop(const_feat)
                warnings.warn(f&#39;Found columns {const_feat} to be constant throughout all the data. They should be removed as no insight will be extracted from them.&#39;)

            if isinstance(df, dd.DataFrame):
                # Make sure that the values are computed, in case we&#39;re using Dask
                means = means.compute()
                stds = stds.compute()

        # Check if the data being denormalized is directly the dataframe
        if data is None:
            if not inplace:
                # Make a copy of the data to avoid potentially unwanted changes to the original dataframe
                data = df.copy()
            else:
                # Use the original dataframe
                data = df

            # Denormalize the right columns
            if columns_to_denormalize is not False:
                print(f&#39;z-score denormalizing columns {columns_to_denormalize}...&#39;)
                data[columns_to_denormalize] = data[columns_to_denormalize] * stds + means

            if columns_to_denormalize_categ is not None:
                # Make sure that the columns_to_denormalize_categ is a list
                if isinstance(columns_to_denormalize_categ, tuple):
                    columns_to_denormalize_categ = [columns_to_denormalize_categ]
                if not isinstance(columns_to_denormalize_categ, list):
                    raise Exception(f&#39;ERROR: The `columns_to_denormalize_categ` argument must be specified as either a single tuple or a list of tuples. Received input with type {type(columns_to_denormalize_categ)}.&#39;)
                print(f&#39;z-score denormalizing columns {columns_to_denormalize_categ} by their associated categories...&#39;)
                for col_tuple in utils.iterations_loop(columns_to_denormalize_categ, see_progress=see_progress):
                    categ_columns = col_tuple[0]
                    column_to_denormalize = col_tuple[1]
                    # Calculate the means and standard deviations
                    means_grpb = df.groupby(categ_columns)[
                        column_to_denormalize].mean()
                    stds_grpb = df.groupby(categ_columns)[
                        column_to_denormalize].std()
                    if isinstance(df, dd.DataFrame):
                        # Make sure that the values are computed, in case we&#39;re using Dask
                        means_grpb = means.compute()
                        stds_grpb = stds.compute()
                    # Get the categories columns as a numpy array, so as to
                    # index the groupby-resulting dataframes of mean and standard
                    # deviation values
                    cat_arr = df[categ_columns].to_numpy()
                    if isinstance(categ_columns, list) and len(categ_columns) &gt; 1:
                        # Convert the sets of values into tuples so as to be
                        # properly readable as dataframe indices
                        cat_arr = list(map(tuple, cat_arr))
                    # Get the mean and standard deviation values in the same
                    # order as the original dataframe&#39;s row order
                    means_cat = means_grpb.loc[cat_arr].to_numpy()
                    stds_cat = stds_grpb.loc[cat_arr].to_numpy()
                    # Denormalize the right categories
                    data[column_to_denormalize] = data[column_to_denormalize] * stds_cat + means_cat
        # Otherwise, the array is denormalized
        else:
            if not inplace:
                # Make a copy of the data to avoid potentially unwanted changes to the original array
                if isinstance(data, torch.Tensor):
                    data = data.clone()
                else:
                    data = data.copy()
            else:
                # Use the original array
                data = data
            if columns_to_denormalize is not False:
                # Dictionaries to retrieve the mean and standard deviation values
                if not isinstance(means, dict):
                    means = dict(means)
                if not isinstance(stds, dict):
                    stds = dict(stds)
                # Dictionary to convert the the array&#39;s column indices into the dataframe&#39;s column names
                idx_to_name = dict(enumerate(feature_columns))
                # Dictionary to convert the dataframe&#39;s column names into the array&#39;s column indices
                name_to_idx = dict([(t[1], t[0])
                                    for t in enumerate(feature_columns)])
                # List of indices of the array&#39;s columns which are needing denormalization
                array_columns_to_denormalize = [name_to_idx[name]
                                                for name in columns_to_denormalize]
                # Denormalize the right columns
                print(f&#39;z-score denormalizing columns {columns_to_denormalize}...&#39;)
                for col in utils.iterations_loop(array_columns_to_denormalize, see_progress=see_progress):
                    if len(data.shape) == 3:
                        data[:, :, col] = data[:, :, col] * stds[idx_to_name[col]] + means[idx_to_name[col]]
                    elif len(data.shape) == 2:
                        data[:, col] = data[:, col] * stds[idx_to_name[col]] + means[idx_to_name[col]]
                    else:
                        raise Exception(f&#39;ERROR: The data array or tensor must be either two or three-dimensional. The provided data has {len(data.shape)} dimensions.&#39;)

        return data

    elif denormalization_method.lower() == &#39;min-max&#39;:
        if columns_to_denormalize is not False:
            mins = df[columns_to_denormalize].min()
            maxs = df[columns_to_denormalize].max()
            # Check if there are constant features
            const_feat = list(mins[mins == maxs].index)
            if len(const_feat) &gt; 0:
                # Prevent constant features from being denormalized
                [columns_to_denormalize.remove(col) for col in const_feat]
                mins = mins.drop(const_feat)
                maxs = maxs.drop(const_feat)
                warnings.warn(f&#39;Found columns {const_feat} to be constant throughout all the data. They should be removed as no insight will be extracted from them.&#39;)

            if isinstance(df, dd.DataFrame):
                # Make sure that the values are computed, in case we&#39;re using Dask
                mins = means.compute()
                maxs = maxs.compute()

        # Check if the data being denormalized is directly the dataframe
        if data is None:
            if not inplace:
                # Make a copy of the data to avoid potentially unwanted changes to the original dataframe
                if isinstance(data, torch.Tensor):
                    data = data.clone()
                else:
                    data = data.copy()
            else:
                # Use the original dataframe
                data = df

            if columns_to_denormalize is not False:
                # Denormalize the right columns
                print(f&#39;min-max denormalizing columns {columns_to_denormalize}...&#39;)
                data[columns_to_denormalize] = data[columns_to_denormalize] * (maxs - mins) + mins

            if columns_to_denormalize_categ is not None:
                # Make sure that the columns_to_denormalize_categ is a list
                if isinstance(columns_to_denormalize_categ, tuple):
                    columns_to_denormalize_categ = [columns_to_denormalize_categ]
                if not isinstance(columns_to_denormalize_categ, list):
                    raise Exception(f&#39;ERROR: The `columns_to_denormalize_categ` argument must be specified as either a single tuple or a list of tuples. Received input with type {type(columns_to_denormalize_categ)}.&#39;)
                print(f&#39;min-max denormalizing columns {columns_to_denormalize_categ} by their associated categories...&#39;)
                for col_tuple in columns_to_denormalize_categ:
                    categ_columns = col_tuple[0]
                    column_to_denormalize = col_tuple[1]
                    # Calculate the minimum and maximum values
                    mins_grpb = df.groupby(col_tuple[0])[col_tuple[1]].min()
                    maxs_grpb = df.groupby(col_tuple[0])[col_tuple[1]].max()
                    if isinstance(df, dd.DataFrame):
                        # Make sure that the values are computed, in case we&#39;re using Dask
                        mins_grpb = mins_grpb.compute()
                        maxs_grpb = maxs_grpb.compute()
                    # Get the categories columns as a numpy array, so as to
                    # index the groupby-resulting dataframes of minimum and
                    # maximum values
                    cat_arr = df[categ_columns].to_numpy()
                    if isinstance(categ_columns, list) and len(categ_columns) &gt; 1:
                        # Convert the sets of values into tuples so as to be
                        # properly readable as dataframe indices
                        cat_arr = list(map(tuple, cat_arr))
                    # Get the minimum and maximum values in the same
                    # order as the original dataframe&#39;s row order
                    mins_cat = mins_grpb.loc[cat_arr].to_numpy()
                    maxs_cat = maxs_grpb.loc[cat_arr].to_numpy()
                    # Denormalize the right categories
                    data[column_to_denormalize] = data[column_to_denormalize] * (maxs_cat - mins_cat) + mins_cat
        # Otherwise, the array is denormalized
        else:
            if not inplace:
                # Make a copy of the data to avoid potentially unwanted changes to the original array
                data = data.clone()
            else:
                # Use the original array
                data = data
            if columns_to_denormalize is not False:
                # Dictionaries to retrieve the min and max values
                column_mins = dict(mins)
                column_maxs = dict(maxs)
                # Dictionary to convert the the array&#39;s column indices into the dataframe&#39;s column names
                idx_to_name = dict(enumerate(feature_columns))
                # Dictionary to convert the dataframe&#39;s column names into the array&#39;s column indices
                name_to_idx = dict([(t[1], t[0])
                                    for t in enumerate(feature_columns)])
                # List of indices of the array&#39;s columns which are needing denormalization
                array_columns_to_denormalize = [name_to_idx[name] for name in columns_to_denormalize]
                # Denormalize the right columns
                print(f&#39;min-max denormalizing columns {columns_to_denormalize}...&#39;)
                for col in utils.iterations_loop(array_columns_to_denormalize, see_progress=see_progress):
                    if len(data.shape) == 3:
                        data[:, :, col] = (data[:, :, col] * (column_maxs[idx_to_name[col]] - column_mins[idx_to_name[col]])
                                           + column_mins[idx_to_name[col]])
                    elif len(data.shape) == 2:
                        data[:, col] = (data[:, col] * (column_maxs[idx_to_name[col]] - column_mins[idx_to_name[col]])
                                        + column_mins[idx_to_name[col]])
                    else:
                        raise Exception(f&#39;ERROR: The data array or tensor must be either two or three-dimensional. The provided data has {len(data.shape)} dimensions.&#39;)

        return data
    else:
        raise ValueError(f&#39;{denormalization_method} isn\&#39;t a valid denormalization method. Available options \
                         are &#34;z-score&#34; and &#34;min-max&#34;.&#39;)</code></pre>
</details>
</dd>
<dt id="data_utils.data_processing.get_clean_label"><code class="name flex">
<span>def <span class="ident">get_clean_label</span></span>(<span>orig_label, clean_labels, column_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the clean version of a given label.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>orig_label</code></strong> :&ensp;<code>string</code></dt>
<dd>Original label name that needs to be converted to the new format.</dd>
<dt><strong><code>clean_labels</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary that converts each original label into a new, cleaner designation.</dd>
<dt><strong><code>column_name</code></strong> :&ensp;<code>string</code>, default <code>None</code></dt>
<dd>Optional parameter to indicate a column name, which is used to specify better the
missing values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>string</code></dt>
<dd>Returns the dictionary key from clean_labels that corresponds to the translation
given to the input label orig_label.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_clean_label(orig_label, clean_labels, column_name=None):
    &#39;&#39;&#39;Gets the clean version of a given label.

    Parameters
    ----------
    orig_label : string
        Original label name that needs to be converted to the new format.
    clean_labels : dict
        Dictionary that converts each original label into a new, cleaner designation.
    column_name : string, default None
        Optional parameter to indicate a column name, which is used to specify better the
        missing values.

    Returns
    -------
    key : string
        Returns the dictionary key from clean_labels that corresponds to the translation
        given to the input label orig_label.
    &#39;&#39;&#39;
    for key in clean_labels:
        if orig_label in clean_labels[key]:
            return key

    # Remaining labels (or lack of one) are considered as missing data
    if column_name is not None:
        return f&#39;{column_name}_missing_value&#39;
    else:
        return &#39;missing_value&#39;</code></pre>
</details>
</dd>
<dt id="data_utils.data_processing.load_chunked_data"><code class="name flex">
<span>def <span class="ident">load_chunked_data</span></span>(<span>file_name, n_chunks=None, data_path='', format='feather', dtypes=None, ordered_naming=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a dataframe in chunks, i.e. in separate files, so as to prevent
memory issues and other problems when loading.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the file where the dataframe is saved.</dd>
<dt><strong><code>n_chunks</code></strong> :&ensp;<code>int</code>, default <code>None</code></dt>
<dd>Number of chunks, i.e. number of files, needed to load the dataframe.
If left unspecified, all the files that match the naming and format will
be loaded.</dd>
<dt><strong><code>data_path</code></strong> :&ensp;<code>str</code>, default <code>''</code></dt>
<dd>Directory path where the file is stored.</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code>, default <code>'feather'</code></dt>
<dd>Data format used to saved the dataframe. Currently available options are
'feather'.</dd>
<dt><strong><code>dtypes</code></strong> :&ensp;<code>dict</code>, default <code>None</code></dt>
<dd>Dictionary that indicates the desired dtype for each column.
e.g. {'Var1': 'float64', 'Var2': 'UInt8', 'Var3': str}</dd>
<dt><strong><code>ordered_naming</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, the method will load data considering an ordered naming,
staring in 0 until n_chunks. Otherwise, it will search for all files
that have the specified naming and format, even if it uses a different
or irregular numbering.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code></dt>
<dd>Loaded dataframe.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_chunked_data(file_name, n_chunks=None, data_path=&#39;&#39;, format=&#39;feather&#39;,
                      dtypes=None, ordered_naming=True):
    &#39;&#39;&#39;Load a dataframe in chunks, i.e. in separate files, so as to prevent
    memory issues and other problems when loading.

    Parameters
    ----------
    file_name : str
        Name of the file where the dataframe is saved.
    n_chunks : int, default None
        Number of chunks, i.e. number of files, needed to load the dataframe.
        If left unspecified, all the files that match the naming and format will
        be loaded.
    data_path : str, default &#39;&#39;
        Directory path where the file is stored.
    format : str, default &#39;feather&#39;
        Data format used to saved the dataframe. Currently available options are
        &#39;feather&#39;.
    dtypes : dict, default None
        Dictionary that indicates the desired dtype for each column.
        e.g. {&#39;Var1&#39;: &#39;float64&#39;, &#39;Var2&#39;: &#39;UInt8&#39;, &#39;Var3&#39;: str}
    ordered_naming : bool, default True
        If set to True, the method will load data considering an ordered naming,
        staring in 0 until n_chunks. Otherwise, it will search for all files
        that have the specified naming and format, even if it uses a different
        or irregular numbering.

    Returns
    -------
    df : pandas.DataFrame or dask.DataFrame
        Loaded dataframe.
    &#39;&#39;&#39;
    # Validate the file format
    format = str(format).lower()
    if format == &#39;feather&#39;:
        file_ext = &#39;.ftr&#39;
    else:
        raise Exception(f&#39;ERROR: Invalid data format &#34;{format}&#34;. Please choose one of the currently supported formats &#34;feather&#34;.&#39;)
    if n_chunks is None or ordered_naming is False:
        # Get a list with the names of the files that can be loaded
        data_files = glob(f&#39;{data_path}{file_name}_*{file_ext}&#39;)
        if n_chunks is None:
            # Load all the files, if no limit is specified
            n_chunks = len(data_files)
    for i in du.utils.iterations_loop(range(n_chunks)):
        if i == 0:
            # Load the first file
            if ordered_naming is True:
                df = pd.read_feather(f&#39;{data_path}{file_name}_{i}{file_ext}&#39;)
            else:
                df = pd.read_feather(data_files[i])
            if dtypes is not None:
                df = du.utils.convert_dtypes(df, dtypes=dtypes, inplace=True)
        else:
            # Load another file and join it with the already loaded ones
            if ordered_naming is True:
                tmp_df = pd.read_feather(f&#39;{data_path}{file_name}_{i}{file_ext}&#39;)
            else:
                tmp_df = pd.read_feather(data_files[i])
            if dtypes is not None:
                tmp_df = du.utils.convert_dtypes(tmp_df, dtypes=dtypes, inplace=True)
            df = pd.concat((df, tmp_df))
            # Remove the already concatenated dataframe from memory
            del tmp_df
    return df</code></pre>
</details>
</dd>
<dt id="data_utils.data_processing.merge_columns"><code class="name flex">
<span>def <span class="ident">merge_columns</span></span>(<span>df, cols_to_merge=None, drop_old_cols=True, separator=';', join_strings=False, see_progress=True, inplace=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Merge columns that have been created, as a consequence of a dataframe
merge operation, resulting in duplicate columns with suffixes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code></dt>
<dd>Dataframe that will have its columns merged.</dd>
<dt><strong><code>cols_to_merge</code></strong> :&ensp;<code>string</code> or <code>list</code> of <code>strings</code>, default <code>None</code></dt>
<dd>The columns which will be regenerated, by merging its duplicates.
If not specified, the algorithm will search for columns with suffixes.</dd>
<dt><strong><code>drop_old_cols</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, the preexisting duplicate columns will be removed.</dd>
<dt><strong><code>separator</code></strong> :&ensp;<code>string</code>, default <code>';'</code></dt>
<dd>Symbol that concatenates each string's words, which will be used to join
the inputs if they are both strings.</dd>
<dt><strong><code>join_strings</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, in case of receiving two string inputs, the algorithm
will joined them using the defined separator. Otherwise, the shortest
string will be returned.</dd>
<dt><strong><code>see_progress</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, a progress bar will show up indicating the execution
of the normalization calculations.</dd>
<dt><strong><code>inplace</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, the original tensor or dataframe will be used and modified
directly. Otherwise, a copy will be created and returned, without
changing the original tensor or dataframe.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data_df</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code></dt>
<dd>Dataframe with the new merged columns.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_columns(df, cols_to_merge=None, drop_old_cols=True, separator=&#39;;&#39;,
                  join_strings=False, see_progress=True, inplace=False):
    &#39;&#39;&#39;Merge columns that have been created, as a consequence of a dataframe
    merge operation, resulting in duplicate columns with suffixes.

    Parameters
    ----------
    df : pandas.DataFrame or dask.DataFrame
        Dataframe that will have its columns merged.
    cols_to_merge : string or list of strings, default None
        The columns which will be regenerated, by merging its duplicates.
        If not specified, the algorithm will search for columns with suffixes.
    drop_old_cols : bool, default True
        If set to True, the preexisting duplicate columns will be removed.
    separator : string, default &#39;;&#39;
        Symbol that concatenates each string&#39;s words, which will be used to join
        the inputs if they are both strings.
    join_strings : bool, default False
        If set to True, in case of receiving two string inputs, the algorithm
        will joined them using the defined separator. Otherwise, the shortest
        string will be returned.
    see_progress : bool, default True
        If set to True, a progress bar will show up indicating the execution
        of the normalization calculations.
    inplace : bool, default False
        If set to True, the original tensor or dataframe will be used and modified
        directly. Otherwise, a copy will be created and returned, without
        changing the original tensor or dataframe.

    Returns
    -------
    data_df : pandas.DataFrame or dask.DataFrame
        Dataframe with the new merged columns.
    &#39;&#39;&#39;
    if not inplace:
        # Make a copy of the data to avoid potentially unwanted changes to the original dataframe
        data_df = df.copy()
    else:
        # Use the original dataframe
        data_df = df
    if cols_to_merge is None:
        print(&#39;Finding columns to merge...&#39;)
        # Find all columns that have typical merging suffixes
        cols_to_merge = set([col.split(&#39;_x&#39;)[0].split(&#39;_y&#39;)[0] for col in df.columns
                             if col.endswith(&#39;_x&#39;) or col.endswith(&#39;_y&#39;)])
    # Make sure that the cols_to_merge is a list
    if isinstance(cols_to_merge, str):
        cols_to_merge = [cols_to_merge]
    print(&#39;Merging the duplicate columns...&#39;)
    for col in utils.iterations_loop(cols_to_merge, see_progress=see_progress):
        # Check if the columns being merged are boolean
        is_bool = all([search_explore.is_boolean_column(data_df, col, n_unique_values=None)]
                       for col in [f&#39;{col}_x&#39;, f&#39;{col}_y&#39;])
        # Create a column, with the original name, merging the associated columns&#39; values
        data_df[col] = data_df.apply(lambda x: merge_values(x[f&#39;{col}_x&#39;], x[f&#39;{col}_y&#39;],
                                                            separator=separator,
                                                            join_strings=join_strings,
                                                            is_bool=is_bool), axis=1)
    if drop_old_cols:
        print(&#39;Removing old columns...&#39;)
        # Remove the old columns, with suffixes `_x` and &#39;_y&#39;, which resulted
        # from the merge of dataframes
        for col in utils.iterations_loop(cols_to_merge, see_progress=see_progress):
            data_df = data_df.drop(columns=[f&#39;{col}_x&#39;, f&#39;{col}_y&#39;])
    print(&#39;Done!&#39;)
    return data_df</code></pre>
</details>
</dd>
<dt id="data_utils.data_processing.merge_values"><code class="name flex">
<span>def <span class="ident">merge_values</span></span>(<span>x1, x2, separator=';', str_over_num=True, join_strings=True, is_bool=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Merge two values, by extracting the non-missing one, their average value
or the non-numeric one.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x1</code></strong></dt>
<dd>Value 1 of the merge operation.</dd>
<dt><strong><code>x2</code></strong></dt>
<dd>Value 2 of the merge operation.</dd>
<dt><strong><code>separator</code></strong> :&ensp;<code>string</code>, default <code>';'</code></dt>
<dd>Symbol that concatenates each string's words, which will be used to join
the inputs if they are both strings.</dd>
<dt><strong><code>str_over_num</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, preference will be given to string inputs. Otherwise,
numeric inputs will be prioritized.</dd>
<dt><strong><code>join_strings</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, in case of receiving two string inputs, the algorithm
will joined them using the defined separator. Otherwise, the shortest
string will be returned.</dd>
<dt><strong><code>is_bool</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, the method will treat the values to merge as boolean
(i.e. it will return either 1, if it's one of the values, or 0).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>x</code></dt>
<dd>Resulting merged value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_values(x1, x2, separator=&#39;;&#39;, str_over_num=True, join_strings=True,
                 is_bool=False):
    &#39;&#39;&#39;Merge two values, by extracting the non-missing one, their average value
    or the non-numeric one.

    Parameters
    ----------
    x1
        Value 1 of the merge operation.
    x2
        Value 2 of the merge operation.
    separator : string, default &#39;;&#39;
        Symbol that concatenates each string&#39;s words, which will be used to join
        the inputs if they are both strings.
    str_over_num : bool, default True
        If set to True, preference will be given to string inputs. Otherwise,
        numeric inputs will be prioritized.
    join_strings : bool, default True
        If set to True, in case of receiving two string inputs, the algorithm
        will joined them using the defined separator. Otherwise, the shortest
        string will be returned.
    is_bool : bool, default False
        If set to True, the method will treat the values to merge as boolean
        (i.e. it will return either 1, if it&#39;s one of the values, or 0).

    Returns
    -------
    x
        Resulting merged value.
    &#39;&#39;&#39;
    if is_bool is True:
        if (x1 is None or utils.is_num_nan(x1)) and (x2 is None or utils.is_num_nan(x2)):
            return 0
        elif (x1 is None or utils.is_num_nan(x1)) and not (x2 is None or utils.is_num_nan(x2)):
            return x2
        elif not (x1 is None or utils.is_num_nan(x1)) and (x2 is None or utils.is_num_nan(x2)):
            return x1
        else:
            return max(x1, x2)
    if x1 is None and x2 is not None:
        return x2
    elif x1 is not None and x2 is None:
        return x1
    elif x1 == x2:
        return x1
    elif ((isinstance(x1, float) or isinstance(x1, int))
    and (isinstance(x2, float) or isinstance(x2, int))):
        # Get the average value between the columns, ignoring NaNs
        return np.nanmean([x1, x2])
    elif isinstance(x1, str) and isinstance(x2, str):
        if not isinstance(separator, str):
            raise Exception(f&#39;ERROR: Separator symbol must be in string format, not {type(separator)}.&#39;)
        if join_strings is True:
            # Join strings through the defined separator
            return separator.join([x1, x2])
        else:
            # Return the shortest string
            if len(x1) &lt;= len(x2):
                return x1
            else:
                return x2
    elif ((isinstance(x1, float) or isinstance(x1, int))
    and not (isinstance(x2, float) or isinstance(x2, int))):
        if utils.is_num_nan(x1) and not utils.is_num_nan(x2):
            # Return the not NaN value
            return x2
        if str_over_num is True:
            # Give preference to string values
            return x2
        else:
            # Give preference to numeric values
            return x1
    elif not ((isinstance(x1, float) or isinstance(x1, int))
    and (isinstance(x2, float) or isinstance(x2, int))):
        if utils.is_num_nan(x2) and not utils.is_num_nan(x1):
            # Return the not NaN value
            return x1
        if str_over_num is True:
            # Give preference to string values
            return x1
        else:
            # Give preference to numeric values
            return x2
    else:
        warnings.warn(f&#39;Both values are different than NaN and are not numeric. Randomly returning the first value {x1}, instead of {x2}.&#39;)
        return x1</code></pre>
</details>
</dd>
<dt id="data_utils.data_processing.missing_values_imputation"><code class="name flex">
<span>def <span class="ident">missing_values_imputation</span></span>(<span>data, columns_to_imputate=None, method='zero', id_column=None, zero_bool=True, reset_index=True, search_by_dtypes=False, inplace=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs missing values imputation to a tensor or dataframe corresponding to
a single column.
NOTE: Most imputation methods don't work with float16 data types and
interpolation can't be applied to nullable integer types.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>torch.Tensor</code> or <code>pandas.DataFrame</code> or <code>dask.DataFrame</code></dt>
<dd>PyTorch tensor corresponding to a single column or a dataframe which will
be imputed.</dd>
<dt><strong><code>columns_to_imputate</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code>, default <code>None</code></dt>
<dd>Specific column(s) to run missing values imputation on. Might be useful
if some columns should be imputated in a specific method, different from
the rest. If left unspecified, all columns will be imputated with the
same method.</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>string</code>, default <code>'zero'</code></dt>
<dd>Imputation method to be used. If user inputs 'zero', it will just fill all
missing values with zero. If the user chooses 'zigzag', it will do a
forward fill, a backward fill and then replace all remaining missing values
with zero (this option is only available for dataframes, not tensors).
If the user selects 'interpolation', missing data will be interpolated based
on known neighboring values and then all possible remaining ones are
replaced with zero (this option is only available for dataframes, not
tensors).</dd>
<dt><strong><code>id_column</code></strong> :&ensp;<code>string</code>, default <code>None</code></dt>
<dd>Name of the column which corresponds to the sequence or subject identifier
in the dataframe. If not specified, the imputation will not differenciate
different IDs nor sequences. Only used if the chosen imputation method is
'zigzag' or 'interpolation'.</dd>
<dt><strong><code>zero_bool</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, it will look for boolean features and replace their
missing values with zero, regardless of the chosen imputation method.</dd>
<dt><strong><code>reset_index</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True (recommended), the dataframe's index will be reset. This
can prevent values from being assigned to the wrong rows.</dd>
<dt><strong><code>search_by_dtypes</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, the method will only look for boolean columns based on
their data type. This is only reliable if all the columns' data types
have been properly set.</dd>
<dt><strong><code>inplace</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, the original tensor or dataframe will be used and modified
directly. Otherwise, a copy will be created and returned, without
changing the original tensor or dataframe.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>tensor</code></strong> :&ensp;<code>torch.Tensor</code></dt>
<dd>Imputed PyTorch tensor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def missing_values_imputation(data, columns_to_imputate=None, method=&#39;zero&#39;,
                              id_column=None, zero_bool=True, reset_index=True,
                              search_by_dtypes=False, inplace=False):
    &#39;&#39;&#39;Performs missing values imputation to a tensor or dataframe corresponding to
    a single column.
    NOTE: Most imputation methods don&#39;t work with float16 data types and
    interpolation can&#39;t be applied to nullable integer types.

    Parameters
    ----------
    data : torch.Tensor or pandas.DataFrame or dask.DataFrame
        PyTorch tensor corresponding to a single column or a dataframe which will
        be imputed.
    columns_to_imputate : str or list of str, default None
        Specific column(s) to run missing values imputation on. Might be useful
        if some columns should be imputated in a specific method, different from
        the rest. If left unspecified, all columns will be imputated with the
        same method.
    method : string, default &#39;zero&#39;
        Imputation method to be used. If user inputs &#39;zero&#39;, it will just fill all
        missing values with zero. If the user chooses &#39;zigzag&#39;, it will do a
        forward fill, a backward fill and then replace all remaining missing values
        with zero (this option is only available for dataframes, not tensors).
        If the user selects &#39;interpolation&#39;, missing data will be interpolated based
        on known neighboring values and then all possible remaining ones are
        replaced with zero (this option is only available for dataframes, not
        tensors).
    id_column : string, default None
        Name of the column which corresponds to the sequence or subject identifier
        in the dataframe. If not specified, the imputation will not differenciate
        different IDs nor sequences. Only used if the chosen imputation method is
        &#39;zigzag&#39; or &#39;interpolation&#39;.
    zero_bool : bool, default True
        If set to True, it will look for boolean features and replace their
        missing values with zero, regardless of the chosen imputation method.
    reset_index : bool, default True
        If set to True (recommended), the dataframe&#39;s index will be reset. This
        can prevent values from being assigned to the wrong rows.
    search_by_dtypes : bool, default False
        If set to True, the method will only look for boolean columns based on
        their data type. This is only reliable if all the columns&#39; data types
        have been properly set.
    inplace : bool, default False
        If set to True, the original tensor or dataframe will be used and modified
        directly. Otherwise, a copy will be created and returned, without
        changing the original tensor or dataframe.

    Returns
    -------
    tensor : torch.Tensor
        Imputed PyTorch tensor.
    &#39;&#39;&#39;
    if ((not isinstance(data, pd.DataFrame))
         and (not isinstance(data, dd.DataFrame))
         and (not isinstance(data, torch.Tensor))):
        raise Exception(f&#39;ERROR: The input data must either be a PyTorch tensor, a Pandas dataframe or a Dask dataframe, not {type(data)}.&#39;)
    if not inplace:
        # Make a copy of the data to avoid potentially unwanted changes to the original data
        if isinstance(data, torch.Tensor):
            data_copy = data.clone()
        else:
            data_copy = data.copy()
    else:
        # Use the original data object
        data_copy = data
    # [TODO] Implement an option to only imputate specified column(s)
    # if columns is None:
    #     columns = list(data_copy.columns)
    if reset_index is True:
        # Reset index to avoid assigning values in the wrong rows
        print(&#39;Resetting the index...&#39;)
        data_copy.reset_index(drop=True, inplace=True)
    if columns_to_imputate is None:
        # Imputate all the columns
        columns_to_imputate = list(data_copy.columns)
    # Make sure that the columns_to_imputate is a list
    if isinstance(columns_to_imputate, str):
        columns_to_imputate = [columns_to_imputate]
    if id_column is not None:
        # Make sure that the ID column is in columns_to_imputate
        if id_column not in columns_to_imputate:
            columns_to_imputate = [id_column] + columns_to_imputate
    if zero_bool is True:
        # Check if there are boolean features
        print(&#39;Searching for boolean features...&#39;)
        bool_feat = search_explore.list_boolean_columns(data_copy, search_by_dtypes=search_by_dtypes)
        if len(bool_feat) &gt; 0:
            # Fill all boolean features&#39; missing values with zeros
            print(&#39;Replacing boolean features\&#39; missing values with zero...&#39;)
            data_copy.loc[:, bool_feat] = data_copy[bool_feat].fillna(value=0)
        # Remove the boolean columns from the list of columns to imputate
        columns_to_imputate = list(set(columns_to_imputate) - set(bool_feat))
    if method.lower() == &#39;zero&#39;:
        # Replace NaN&#39;s with zeros
        print(&#39;Replacing missing values with zero...&#39;)
        if isinstance(data, pd.DataFrame) or isinstance(data, dd.DataFrame):
            data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].fillna(value=0)
        elif isinstance(data, torch.Tensor):
            # [TODO] Add the ability to specify the tensor columns to imputate
            data_copy = torch.where(data_copy != data_copy, torch.zeros_like(data_copy), data_copy)
    elif method.lower() == &#39;zigzag&#39;:
        if isinstance(data, pd.DataFrame) or isinstance(data, dd.DataFrame):
            if id_column is not None:
                # Perform imputation on each ID separately
                # Forward fill and backward fill
                print(&#39;Forward filling and backward filling missing values...&#39;)
                data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].groupby(id_column).apply(lambda group: group.ffill().bfill())
                # Replace remaining missing values with zero
                print(&#39;Replacing remaining missing values with zero...&#39;)
                data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].fillna(value=0)
            else:
                # Apply imputation on all the data as one single sequence
                # Forward fill
                print(&#39;Forward filling missing values...&#39;)
                data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].ffill()
                # Backward fill
                print(&#39;Backward filling missing values...&#39;)
                data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].bfill()
                # Replace remaining missing values with zero
                print(&#39;Replacing remaining missing values with zero...&#39;)
                data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].fillna(value=0)
        elif isinstance(data, torch.Tensor):
            raise Exception(&#39;ERROR: PyTorch tensors aren\&#39;t supported in the zigzag imputation method. Please use a dataframe instead.&#39;)
    elif method.lower() == &#39;interpolation&#39;:
        if isinstance(data, pd.DataFrame) or isinstance(data, dd.DataFrame):
            # Linear interpolation, placing a linear scale between known points and doing simple
            # backward and forward fill, when the missing value doesn&#39;t have known data points
            # before or after, respectively
            # NOTE: Since the interpolate method doesn&#39;t work on nullable integer data types,
            # we need to find and separate columns with that dtype and apply zigzag imputation on them
            columns_cant_interpolate = list()
            for col in columns_to_imputate:
                if ((&#39;Int&#39; in str(data[col].dtype) or &#39;boolean&#39; in str(data[col].dtype))
                and col != id_column):
                    columns_cant_interpolate.append(col)
                    columns_to_imputate.remove(col)
            if id_column is not None:
                try:
                    if len(columns_cant_interpolate) &gt; 0:
                        # Perform zigzag imputation on columns that can&#39;t be interpolated
                        print(&#39;Running zigzag imputation on columns that can\&#39;t be interpolated...&#39;)
                        print(f&#39;(These columns are {columns_cant_interpolate})&#39;)
                        columns_cant_interpolate = [id_column] + columns_cant_interpolate
                        # Forward fill and backward fill
                        print(&#39;Forward filling and backward filling missing values...&#39;)
                        data_copy.loc[:, columns_cant_interpolate] = data_copy[columns_cant_interpolate].groupby(id_column).apply(lambda group: group.ffill().bfill())
                        # Replace remaining missing values with zero
                        print(&#39;Replacing remaining missing values with zero...&#39;)
                        data_copy.loc[:, columns_cant_interpolate] = data_copy[columns_cant_interpolate].fillna(value=0)
                    # There&#39;s no need to interpolate if the only column in columns_to_imputate is the ID column
                    if len(columns_to_imputate) &gt; 1:
                        # Perform imputation on each ID separately
                        print(&#39;Interpolating missing values...&#39;)
                        data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].groupby(id_column)[columns_to_imputate].apply(lambda group: group.interpolate(limit_direction=&#39;both&#39;))
                        # Replace remaining missing values with zero
                        print(&#39;Replacing remaining missing values with zero...&#39;)
                        data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].fillna(value=0)
                except ValueError as e:
                    warnings.warn(f&#39;Initial attempt to interpolate failed. Original exception message: &#34;{str(e)}&#34;\nTrying again after replacing all possible &lt;NA&gt; occurences with a Numpy NaN.&#39;)
                    # Save the current data types
                    dtype_dict = dict(data_copy.dtypes)
                    # Replace the &#39;&lt;NA&gt;&#39; objects with NumPy&#39;s NaN
                    data_copy = data_copy.applymap(lambda x: x if not utils.is_num_nan(x) else np.nan)
                    print(&#39;Finished replacing all possible &lt;NA&gt; values.&#39;)
                    # Perform imputation on each ID separately
                    print(&#39;Interpolating missing values...&#39;)
                    data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].groupby(id_column)[columns_to_imputate].apply(lambda group: group.interpolate(limit_direction=&#39;both&#39;))
                    # Replace remaining missing values with zero
                    print(&#39;Replacing remaining missing values with zero...&#39;)
                    data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].fillna(value=0)
                    # Convert the data types back to the original ones
                    print(&#39;Converting data types back to the original ones...&#39;)
                    data_copy = utils.convert_dtypes(data_copy, dtypes=dtype_dict, inplace=True)
            else:
                try:
                    if len(columns_cant_interpolate) &gt; 0:
                        # Perform zigzag imputation on columns that can&#39;t be interpolated
                        print(&#39;Running zigzag imputation on columns that can\&#39;t be interpolated...&#39;)
                        print(f&#39;(These columns are {columns_cant_interpolate})&#39;)
                        # Forward fill
                        print(&#39;Forward filling missing values...&#39;)
                        data_copy.loc[:, columns_cant_interpolate] = data_copy[columns_cant_interpolate].ffill()
                        # Backward fill
                        print(&#39;Backward filling missing values...&#39;)
                        data_copy.loc[:, columns_cant_interpolate] = data_copy[columns_cant_interpolate].bfill()
                        # Replace remaining missing values with zero
                        print(&#39;Replacing remaining missing values with zero...&#39;)
                        data_copy.loc[:, columns_cant_interpolate] = data_copy[columns_cant_interpolate].fillna(value=0)
                    # There&#39;s no need to interpolate if columns_to_imputate is empty
                    if len(columns_to_imputate) &gt; 0:
                        # Apply imputation on all the data as one single sequence
                        print(&#39;Interpolating missing values...&#39;)
                        data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].interpolate(limit_direction=&#39;both&#39;)
                        # Replace remaining missing values with zero
                        print(&#39;Replacing remaining missing values with zero...&#39;)
                        data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].fillna(value=0)
                except ValueError as e:
                    warnings.warn(f&#39;Initial attempt to interpolate failed. Original exception message: &#34;{str(e)}&#34;\nTrying again after replacing all possible &lt;NA&gt; occurences with a Numpy NaN.&#39;)
                    # Save the current data types
                    dtype_dict = dict(data_copy.dtypes)
                    data_copy = utils.convert_dtypes(data_copy, dtypes=dtype_dict, inplace=True)
                    print(&#39;Finished replacing all possible &lt;NA&gt; values.&#39;)
                    # Apply imputation on all the data as one single sequence
                    print(&#39;Interpolating missing values...&#39;)
                    data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].interpolate(limit_direction=&#39;both&#39;)
                    # Replace remaining missing values with zero
                    print(&#39;Replacing remaining missing values with zero...&#39;)
                    data_copy.loc[:, columns_to_imputate] = data_copy[columns_to_imputate].fillna(value=0)
                    # Convert the data types back to the original ones
                    print(&#39;Converting data types back to the original ones...&#39;)
                    data_copy = utils.convert_dtypes(data_copy, dtypes=dtype_dict, inplace=True)
        elif isinstance(data, torch.Tensor):
            raise Exception(&#39;ERROR: PyTorch tensors aren\&#39;t supported in the interpolation imputation method. Please use a dataframe instead.&#39;)
    else:
        raise Exception(f&#39;ERROR: Unsupported {method} imputation method. Currently available options are `zero` and `zigzag`.&#39;)
    # [TODO] Add other, more complex imputation methods, like a denoising autoencoder
    print(&#39;Done!&#39;)
    return data_copy</code></pre>
</details>
</dd>
<dt id="data_utils.data_processing.normalize_data"><code class="name flex">
<span>def <span class="ident">normalize_data</span></span>(<span>df, data=None, id_columns=['patientunitstayid', 'ts'], normalization_method='z-score', columns_to_normalize=None, columns_to_normalize_categ=None, categ_columns=None, see_progress=True, get_stats=False, search_by_dtypes=False, inplace=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs data normalization to a continuous valued tensor or dataframe,
changing the scale of the data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code></dt>
<dd>Original Pandas or Dask dataframe which is used to correctly calculate the
necessary statistical values used in the normalization. These values
can't be calculated from the tensor as it might have been padded. If
the data tensor isn't specified, the normalization is applied directly
on the dataframe.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>torch.Tensor</code>, default <code>None</code></dt>
<dd>PyTorch tensor corresponding to the data which will be normalized
by the specified normalization method. If the data tensor isn't
specified, the normalization is applied directly on the dataframe.</dd>
<dt><strong><code>id_columns</code></strong> :&ensp;<code>string</code> or <code>list</code> of <code>strings</code>, default <code>['subject_id', 'ts']</code></dt>
<dd>List of columns names which represent identifier columns. These are not
supposed to be normalized.</dd>
<dt><strong><code>normalization_method</code></strong> :&ensp;<code>string</code>, default <code>'z-score'</code></dt>
<dd>Specifies the normalization method used. It can be a z-score
normalization, where the data is subtracted of its mean and divided
by the standard deviation, which makes it have zero average and unit
variance, much like a standard normal distribution; it can be a
min-max normalization, where the data is subtracted by its minimum
value and then divided by the difference between the minimum and the
maximum value, getting to a fixed range from 0 to 1.</dd>
<dt><strong><code>columns_to_normalize</code></strong> :&ensp;<code>string</code> or <code>list</code> of <code>strings</code>, default <code>None</code></dt>
<dd>If specified, the columns provided in the list are the only ones that
will be normalized. If set to False, no column will be normalized directly,
although columns can still be normalized in groups of categories, if
specified in the <code>columns_to_normalize_categ</code> parameter. Otherwise, all
continuous columns will be normalized.</dd>
<dt><strong><code>columns_to_normalize_categ</code></strong> :&ensp;<code>tuple</code> or <code>list</code> of <code>tuples</code> of <code>tuples</code>, default <code>None</code></dt>
<dd>If specified, the columns provided in the list are going to be
normalized on their categories. That is, the values (column 2 in the
tuple) are normalized with stats of their respective categories (column
1 of the tuple). Otherwise, no column will be normalized on their
categories.</dd>
<dt><strong><code>categ_columns</code></strong> :&ensp;<code>string</code> or <code>list</code> of <code>strings</code>, default <code>None</code></dt>
<dd>If specified, the columns in the list, which represent categorical
features, which either are a label or will be embedded, aren't
going to be normalized.</dd>
<dt><strong><code>see_progress</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, a progress bar will show up indicating the execution
of the normalization calculations.</dd>
<dt><strong><code>get_stats</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, the stats used to normalize the data (e.g. mean and
standard deviation) are also outputed.</dd>
<dt><strong><code>search_by_dtypes</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, the method will only look for boolean columns based on
their data type. This is only reliable if all the columns' data types
have been properly set.</dd>
<dt><strong><code>inplace</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, the original dataframe will be used and modified
directly. Otherwise, a copy will be created and returned, without
changing the original dataframe.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code> or <code>torch.Tensor</code></dt>
<dd>Normalized Pandas or Dask dataframe or PyTorch tensor.</dd>
<dt><code>If get_stats == True and normalization_method == 'z-score':</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code>float</code> or <code>dict</code> or <code>list</code> of <code>floats</code> or <code>list</code> of <code>dicts</code></dt>
<dd>Mean value(s) used in the data normalization.</dd>
<dt><strong><code>std</code></strong> :&ensp;<code>float</code> or <code>dict</code> or <code>list</code> of <code>floats</code> or <code>list</code> of <code>dicts</code></dt>
<dd>Standard deviation value(s) used in the data normalization.</dd>
<dt><code>If get_stats == True and normalization_method == 'min-max':</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>min</code></strong> :&ensp;<code>dict</code></dt>
<dd>Minimum value(s) used in the data normalization.</dd>
<dt><strong><code>max</code></strong> :&ensp;<code>dict</code></dt>
<dd>Maximum value(s) used in the data normalization.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_data(df, data=None, id_columns=[&#39;patientunitstayid&#39;, &#39;ts&#39;],
                   normalization_method=&#39;z-score&#39;, columns_to_normalize=None,
                   columns_to_normalize_categ=None, categ_columns=None,
                   see_progress=True, get_stats=False,
                   search_by_dtypes=False, inplace=False):
    &#39;&#39;&#39;Performs data normalization to a continuous valued tensor or dataframe,
       changing the scale of the data.

    Parameters
    ----------
    df : pandas.DataFrame or dask.DataFrame
        Original Pandas or Dask dataframe which is used to correctly calculate the
        necessary statistical values used in the normalization. These values
        can&#39;t be calculated from the tensor as it might have been padded. If
        the data tensor isn&#39;t specified, the normalization is applied directly
        on the dataframe.
    data : torch.Tensor, default None
        PyTorch tensor corresponding to the data which will be normalized
        by the specified normalization method. If the data tensor isn&#39;t
        specified, the normalization is applied directly on the dataframe.
    id_columns : string or list of strings, default [&#39;subject_id&#39;, &#39;ts&#39;]
        List of columns names which represent identifier columns. These are not
        supposed to be normalized.
    normalization_method : string, default &#39;z-score&#39;
        Specifies the normalization method used. It can be a z-score
        normalization, where the data is subtracted of its mean and divided
        by the standard deviation, which makes it have zero average and unit
        variance, much like a standard normal distribution; it can be a
        min-max normalization, where the data is subtracted by its minimum
        value and then divided by the difference between the minimum and the
        maximum value, getting to a fixed range from 0 to 1.
    columns_to_normalize : string or list of strings, default None
        If specified, the columns provided in the list are the only ones that
        will be normalized. If set to False, no column will be normalized directly,
        although columns can still be normalized in groups of categories, if
        specified in the `columns_to_normalize_categ` parameter. Otherwise, all
        continuous columns will be normalized.
    columns_to_normalize_categ : tuple or list of tuples of tuples, default None
        If specified, the columns provided in the list are going to be
        normalized on their categories. That is, the values (column 2 in the
        tuple) are normalized with stats of their respective categories (column
        1 of the tuple). Otherwise, no column will be normalized on their
        categories.
    categ_columns : string or list of strings, default None
        If specified, the columns in the list, which represent categorical
        features, which either are a label or will be embedded, aren&#39;t
        going to be normalized.
    see_progress : bool, default True
        If set to True, a progress bar will show up indicating the execution
        of the normalization calculations.
    get_stats : bool, default False
        If set to True, the stats used to normalize the data (e.g. mean and
        standard deviation) are also outputed.
    search_by_dtypes : bool, default False
        If set to True, the method will only look for boolean columns based on
        their data type. This is only reliable if all the columns&#39; data types
        have been properly set.
    inplace : bool, default False
        If set to True, the original dataframe will be used and modified
        directly. Otherwise, a copy will be created and returned, without
        changing the original dataframe.

    Returns
    -------
    data : pandas.DataFrame or dask.DataFrame or torch.Tensor
        Normalized Pandas or Dask dataframe or PyTorch tensor.

    If get_stats == True and normalization_method == &#39;z-score&#39;:

    mean : float or dict or list of floats or list of dicts
        Mean value(s) used in the data normalization.
    std : float or dict or list of floats or list of dicts
        Standard deviation value(s) used in the data normalization.

    If get_stats == True and normalization_method == &#39;min-max&#39;:

    min : dict
        Minimum value(s) used in the data normalization.
    max : dict
        Maximum value(s) used in the data normalization.
    &#39;&#39;&#39;
    # Check if specific columns have been specified for normalization
    if columns_to_normalize is None:
        # List of all columns in the dataframe
        feature_columns = list(df.columns)
        # Normalize all non identifier continuous columns, ignore one hot encoded ones
        columns_to_normalize = feature_columns
        if id_columns is not None:
            # Make sure that the id_columns is a list
            if isinstance(id_columns, str):
                id_columns = [id_columns]
            if not isinstance(id_columns, list):
                raise Exception(f&#39;ERROR: The `id_columns` argument must be specified as either a single string or a list of strings. Received input with type {type(id_columns)}.&#39;)
            # List of all columns in the dataframe, except the ID columns
            [columns_to_normalize.remove(col) for col in id_columns]
        if categ_columns is not None:
            # Make sure that the categ_columns is a list
            if isinstance(categ_columns, str):
                categ_columns = [categ_columns]
            if not isinstance(categ_columns, list):
                raise Exception(f&#39;ERROR: The `categ_columns` argument must be specified as either a single string or a list of strings. Received input with type {type(categ_columns)}.&#39;)
            # Prevent all features that will be embedded from being normalized
            [columns_to_normalize.remove(col) for col in categ_columns]
        # List of boolean or one hot encoded columns
        boolean_cols = search_explore.list_boolean_columns(df[columns_to_normalize], search_by_dtypes=search_by_dtypes)
        if boolean_cols is not None:
            # Prevent boolean features from being normalized
            [columns_to_normalize.remove(col) for col in boolean_cols]
        # Remove all non numeric columns that could be left
        columns_to_normalize = [col for col in columns_to_normalize
                                if df[col].dtype == int or df[col].dtype == float]
        if columns_to_normalize is None:
            print(&#39;No columns to normalize, returning the original dataframe.&#39;)
            return df

    # Make sure that the columns_to_normalize is a list
    if isinstance(columns_to_normalize, str):
        columns_to_normalize = [columns_to_normalize]
    if not isinstance(columns_to_normalize, list) and not isinstance(columns_to_normalize, bool):
        raise Exception(f&#39;ERROR: The `columns_to_normalize` argument must be specified as either a single string, a list of strings or a boolean. Received input with type {type(columns_to_normalize)}.&#39;)

    if type(normalization_method) is not str:
        raise ValueError(&#39;Argument normalization_method should be a string. Available options are &#34;z-score&#34; and &#34;min-max&#34;.&#39;)

    if normalization_method.lower() == &#39;z-score&#39;:
        if columns_to_normalize is not False:
            # Calculate the means and standard deviations
            means = df[columns_to_normalize].mean()
            stds = df[columns_to_normalize].std()
            # Check if there are constant features
            const_feat = list(stds[stds == 0].index)
            if len(const_feat) &gt; 0:
                # Prevent constant features from being normalized
                [columns_to_normalize.remove(col) for col in const_feat]
                means = means.drop(const_feat)
                stds = stds.drop(const_feat)
                warnings.warn(f&#39;Found columns {const_feat} to be constant throughout all the data. They should be removed as no insight will be extracted from them.&#39;)

            if isinstance(df, dd.DataFrame):
                # Make sure that the values are computed, in case we&#39;re using Dask
                means = means.compute()
                stds = stds.compute()

        # Check if the data being normalized is directly the dataframe
        if data is None:
            if not inplace:
                # Make a copy of the data to avoid potentially unwanted changes to the original dataframe
                data = df.copy()
            else:
                # Use the original dataframe
                data = df

            # Normalize the right columns
            if columns_to_normalize is not False:
                print(f&#39;z-score normalizing columns {columns_to_normalize}...&#39;)
                data[columns_to_normalize] = (data[columns_to_normalize] - means) / stds

            if columns_to_normalize_categ is not None:
                if get_stats is True:
                    mean_list = []
                    std_list = []
                # Make sure that the columns_to_normalize_categ is a list
                if isinstance(columns_to_normalize_categ, tuple):
                    columns_to_normalize_categ = [columns_to_normalize_categ]
                if not isinstance(columns_to_normalize_categ, list):
                    raise Exception(f&#39;ERROR: The `columns_to_normalize_categ` argument must be specified as either a single tuple or a list of tuples. Received input with type {type(columns_to_normalize_categ)}.&#39;)
                print(f&#39;z-score normalizing columns {columns_to_normalize_categ} by their associated categories...&#39;)
                for col_tuple in utils.iterations_loop(columns_to_normalize_categ, see_progress=see_progress):
                    categ_columns = col_tuple[0]
                    column_to_normalize = col_tuple[1]
                    # Calculate the means and standard deviations
                    means_grpb = df.groupby(categ_columns)[column_to_normalize].mean()
                    stds_grpb = df.groupby(categ_columns)[column_to_normalize].std()
                    if isinstance(df, dd.DataFrame):
                        # Make sure that the values are computed, in case we&#39;re using Dask
                        means_grpb = means.compute()
                        stds_grpb = stds.compute()
                    if get_stats is True:
                        if isinstance(column_to_normalize, str):
                            # Make sure that the feature being normalized has its name specified in the stats
                            tmp_mean_grpb = dict()
                            tmp_std_grpb = dict()
                            tmp_mean_grpb[column_to_normalize] = means_grpb.to_dict()
                            tmp_std_grpb[column_to_normalize] = stds_grpb.to_dict()
                            # Add the current stats values to the output lists
                            mean_list.append(tmp_mean_grpb)
                            std_list.append(tmp_std_grpb)
                        else:
                            # Add the current stats values to the output lists
                            mean_list.append(means_grpb.to_dict())
                            std_list.append(stds_grpb.to_dict())
                    # Get the categories columns as a numpy array, so as to
                    # index the groupby-resulting dataframes of mean and standard
                    # deviation values
                    cat_arr = df[categ_columns].to_numpy()
                    if isinstance(categ_columns, list) and len(categ_columns) &gt; 1:
                        # Convert the sets of values into tuples so as to be
                        # properly readable as dataframe indices
                        cat_arr = list(map(tuple, cat_arr))
                    # Get the mean and standard deviation values in the same
                    # order as the original dataframe&#39;s row order
                    means_cat = means_grpb.loc[cat_arr].to_numpy()
                    stds_cat = stds_grpb.loc[cat_arr].to_numpy()
                    # Normalize the right categories
                    data[column_to_normalize] = (data[column_to_normalize] - means_cat) / stds_cat
                if get_stats is True:
                    # Merge all the stats dictionaries
                    mean_categ_dict = utils.merge_dicts(mean_list)
                    std_categ_dict = utils.merge_dicts(std_list)

        # Otherwise, the tensor is normalized
        else:
            if columns_to_normalize is not False:
                # Dictionaries to retrieve the mean and standard deviation values
                column_means = dict(means)
                column_stds = dict(stds)
                # Dictionary to convert the the tensor&#39;s column indices into the dataframe&#39;s column names
                idx_to_name = dict(enumerate(df.columns))
                # Dictionary to convert the dataframe&#39;s column names into the tensor&#39;s column indices
                name_to_idx = dict([(t[1], t[0]) for t in enumerate(df.columns)])
                # List of indices of the tensor&#39;s columns which are needing normalization
                tensor_columns_to_normalize = [name_to_idx[name] for name in columns_to_normalize]
                # Normalize the right columns
                print(f&#39;z-score normalizing columns {columns_to_normalize}...&#39;)
                for col in utils.iterations_loop(tensor_columns_to_normalize, see_progress=see_progress):
                    data[:, :, col] = ((data[:, :, col] - column_means[idx_to_name[col]])
                                       / column_stds[idx_to_name[col]])

        if get_stats is False:
            return data
        elif columns_to_normalize is not False and columns_to_normalize_categ is not None:
            return data, means.to_dict(), stds.to_dict(), mean_categ_dict, std_categ_dict
        elif columns_to_normalize is not False and columns_to_normalize_categ is None:
            return data, means.to_dict(), stds.to_dict()
        elif columns_to_normalize is False and columns_to_normalize_categ is not None:
            return data, mean_categ_dict, std_categ_dict

    elif normalization_method.lower() == &#39;min-max&#39;:
        if columns_to_normalize is not False:
            mins = df[columns_to_normalize].min()
            maxs = df[columns_to_normalize].max()
            # Check if there are constant features
            const_feat = list(mins[mins == maxs].index)
            if len(const_feat) &gt; 0:
                # Prevent constant features from being normalized
                [columns_to_normalize.remove(col) for col in const_feat]
                mins = mins.drop(const_feat)
                maxs = maxs.drop(const_feat)
                warnings.warn(f&#39;Found columns {const_feat} to be constant throughout all the data. They should be removed as no insight will be extracted from them.&#39;)

            if isinstance(df, dd.DataFrame):
                # Make sure that the values are computed, in case we&#39;re using Dask
                mins = means.compute()
                maxs = maxs.compute()

        # Check if the data being normalized is directly the dataframe
        if data is None:
            if not inplace:
                # Make a copy of the data to avoid potentially unwanted changes to the original dataframe
                data = df.copy()
            else:
                # Use the original dataframe
                data = df

            if columns_to_normalize is not False:
                # Normalize the right columns
                print(f&#39;min-max normalizing columns {columns_to_normalize}...&#39;)
                data[columns_to_normalize] = (data[columns_to_normalize] - mins) / (maxs - mins)

            if columns_to_normalize_categ is not None:
                if get_stats is True:
                    min_list = []
                    max_list = []
                # Make sure that the columns_to_normalize_categ is a list
                if isinstance(columns_to_normalize_categ, tuple):
                    columns_to_normalize_categ = [columns_to_normalize_categ]
                if not isinstance(columns_to_normalize_categ, list):
                    raise Exception(f&#39;ERROR: The `columns_to_normalize_categ` argument must be specified as either a single tuple or a list of tuples. Received input with type {type(columns_to_normalize_categ)}.&#39;)
                print(f&#39;min-max normalizing columns {columns_to_normalize_categ} by their associated categories...&#39;)
                for col_tuple in columns_to_normalize_categ:
                    categ_columns = col_tuple[0]
                    column_to_normalize = col_tuple[1]
                    # Calculate the minimum and maximum values
                    mins_grpb = df.groupby(col_tuple[0])[col_tuple[1]].min()
                    maxs_grpb = df.groupby(col_tuple[0])[col_tuple[1]].max()
                    if isinstance(df, dd.DataFrame):
                        # Make sure that the values are computed, in case we&#39;re using Dask
                        mins_grpb = mins_grpb.compute()
                        maxs_grpb = maxs_grpb.compute()
                    if get_stats is True:
                        if isinstance(column_to_normalize, str):
                            # Make sure that the feature being normalized has its name specified in the stats
                            tmp_min_grpb = dict()
                            tmp_max_grpb = dict()
                            tmp_min_grpb[column_to_normalize] = mins_grpb.to_dict()
                            tmp_max_grpb[column_to_normalize] = maxs_grpb.to_dict()
                            # Add the current stats values to the output lists
                            min_list.append(tmp_min_grpb)
                            max_list.append(tmp_max_grpb)
                        else:
                            # Add the current stats values to the output lists
                            min_list.append(mins_grpb.to_dict())
                            max_list.append(maxs_grpb.to_dict())
                    # Get the categories columns as a numpy array, so as to
                    # index the groupby-resulting dataframes of minimum and
                    # maximum values
                    cat_arr = df[categ_columns].to_numpy()
                    if isinstance(categ_columns, list) and len(categ_columns) &gt; 1:
                        # Convert the sets of values into tuples so as to be
                        # properly readable as dataframe indices
                        cat_arr = list(map(tuple, cat_arr))
                    # Get the minimum and maximum values in the same
                    # order as the original dataframe&#39;s row order
                    mins_cat = mins_grpb.loc[cat_arr].to_numpy()
                    maxs_cat = maxs_grpb.loc[cat_arr].to_numpy()
                    # Normalize the right categories
                    data[column_to_normalize] = (data[column_to_normalize] - mins_cat) / (maxs_cat - mins_cat)
                if get_stats is True:
                    # Merge all the stats dictionaries
                    min_categ_dict = utils.merge_dicts(min_list)
                    max_categ_dict = utils.merge_dicts(max_list)
        # Otherwise, the tensor is normalized
        else:
            if columns_to_normalize is not False:
                # Dictionaries to retrieve the min and max values
                column_mins = dict(mins)
                column_maxs = dict(maxs)
                # Dictionary to convert the the tensor&#39;s column indices into the dataframe&#39;s column names
                idx_to_name = dict(enumerate(df.columns))
                # Dictionary to convert the dataframe&#39;s column names into the tensor&#39;s column indices
                name_to_idx = dict([(t[1], t[0]) for t in enumerate(df.columns)])
                # List of indices of the tensor&#39;s columns which are needing normalization
                tensor_columns_to_normalize = [name_to_idx[name] for name in columns_to_normalize]
                # Normalize the right columns
                print(f&#39;min-max normalizing columns {columns_to_normalize}...&#39;)
                for col in utils.iterations_loop(tensor_columns_to_normalize, see_progress=see_progress):
                    data[:, :, col] = ((data[:, :, col] - column_mins[idx_to_name[col]])
                                       / (column_maxs[idx_to_name[col]] - column_mins[idx_to_name[col]]))

        if get_stats is False:
            return data
        elif columns_to_normalize is not False and columns_to_normalize_categ is not None:
            return data, mins.to_dict(), maxs.to_dict(), min_categ_dict, max_categ_dict
        elif columns_to_normalize is not False and columns_to_normalize_categ is None:
            return data, mins.to_dict(), maxs.to_dict()
        elif columns_to_normalize is False and columns_to_normalize_categ is not None:
            return data, min_categ_dict, max_categ_dict
    else:
        raise ValueError(f&#39;{normalization_method} isn\&#39;t a valid normalization method. Available options \
                         are &#34;z-score&#34; and &#34;min-max&#34;.&#39;)</code></pre>
</details>
</dd>
<dt id="data_utils.data_processing.one_hot_encoding_dataframe"><code class="name flex">
<span>def <span class="ident">one_hot_encoding_dataframe</span></span>(<span>df, columns, clean_name=True, clean_missing_values=True, specific_nan_strings=[], lower_case=False, has_nan=False, join_rows=False, join_by=['patientunitstayid', 'ts'], get_new_column_names=False, search_by_dtypes=False, inplace=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Transforms specified column(s) from a dataframe into a one hot encoding
representation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code></dt>
<dd>Dataframe that will be used, which contains the specified column.</dd>
<dt><strong><code>columns</code></strong> :&ensp;<code>list</code> of <code>strings</code></dt>
<dd>Name of the column(s) that will be conveted to one hot encoding.</dd>
<dt><strong><code>clean_name</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to true, changes the name of the categorical values into lower
case, with words separated by an underscore instead of space.</dd>
<dt><strong><code>clean_missing_values</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, the algorithm will search for missing value
representations and replace them with the standard, NumPy NaN value.</dd>
<dt><strong><code>specific_nan_strings</code></strong> :&ensp;<code>list</code> of <code>strings</code>, default <code>[]</code></dt>
<dd>Parameter where the user can specify additional strings that
should correspond to missing values.</dd>
<dt><strong><code>lower_case</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, all strings will be converted to lower case.</dd>
<dt><strong><code>has_nan</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to true, will first fill the missing values (NaN) with the string
f'{column}_missing_value'.</dd>
<dt><strong><code>join_rows</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to true, will group the rows created by the one hot encoding by
summing the boolean values in the rows that have the same identifiers.</dd>
<dt><strong><code>join_by</code></strong> :&ensp;<code>string</code> or <code>list</code>, default <code>['subject_id', 'ts'])</code></dt>
<dd>Name of the column (or columns) which serves as a unique identifier of
the dataframe's rows, which will be used in the groupby operation if the
parameter join_rows is set to true. Can be a string (single column) or a
list of strings (multiple columns).</dd>
<dt><strong><code>get_new_column_names</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, the names of the new columns will also be outputed.</dd>
<dt><strong><code>search_by_dtypes</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, the method will only look for boolean columns based on
their data type. This is only reliable if all the columns' data types
have been properly set.</dd>
<dt><strong><code>inplace</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, the original dataframe will be used and modified
directly. Otherwise, a copy will be created and returned, without
changing the original dataframe.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ColumnNotFoundError</code></dt>
<dd>Column name not found in the dataframe.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ohe_df</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code></dt>
<dd>Returns a new dataframe with the specified column in a one hot encoding
representation.</dd>
<dt><strong><code>new_column_names</code></strong> :&ensp;<code>list</code> of <code>strings</code></dt>
<dd>List of the new, one hot encoded columns' names.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def one_hot_encoding_dataframe(df, columns, clean_name=True, clean_missing_values=True,
                               specific_nan_strings=[], lower_case=False,
                               has_nan=False, join_rows=False,
                               join_by=[&#39;patientunitstayid&#39;, &#39;ts&#39;],
                               get_new_column_names=False,
                               search_by_dtypes=False, inplace=False):
    &#39;&#39;&#39;Transforms specified column(s) from a dataframe into a one hot encoding
    representation.

    Parameters
    ----------
    df : pandas.DataFrame or dask.DataFrame
        Dataframe that will be used, which contains the specified column.
    columns : list of strings
        Name of the column(s) that will be conveted to one hot encoding.
    clean_name : bool, default True
        If set to true, changes the name of the categorical values into lower
        case, with words separated by an underscore instead of space.
    clean_missing_values : bool, default True
        If set to True, the algorithm will search for missing value
        representations and replace them with the standard, NumPy NaN value.
    specific_nan_strings : list of strings, default []
        Parameter where the user can specify additional strings that
        should correspond to missing values.
    lower_case : bool, default False
        If set to True, all strings will be converted to lower case.
    has_nan : bool, default False
        If set to true, will first fill the missing values (NaN) with the string
        f&#39;{column}_missing_value&#39;.
    join_rows : bool, default False
        If set to true, will group the rows created by the one hot encoding by
        summing the boolean values in the rows that have the same identifiers.
    join_by : string or list, default [&#39;subject_id&#39;, &#39;ts&#39;])
        Name of the column (or columns) which serves as a unique identifier of
        the dataframe&#39;s rows, which will be used in the groupby operation if the
        parameter join_rows is set to true. Can be a string (single column) or a
        list of strings (multiple columns).
    get_new_column_names : bool, default False
        If set to True, the names of the new columns will also be outputed.
    search_by_dtypes : bool, default False
        If set to True, the method will only look for boolean columns based on
        their data type. This is only reliable if all the columns&#39; data types
        have been properly set.
    inplace : bool, default False
        If set to True, the original dataframe will be used and modified
        directly. Otherwise, a copy will be created and returned, without
        changing the original dataframe.

    Raises
    ------
    ColumnNotFoundError
        Column name not found in the dataframe.

    Returns
    -------
    ohe_df : pandas.DataFrame or dask.DataFrame
        Returns a new dataframe with the specified column in a one hot encoding
        representation.
    new_column_names : list of strings
        List of the new, one hot encoded columns&#39; names.
    &#39;&#39;&#39;
    if not inplace:
        # Make a copy of the data to avoid potentially unwanted changes to the original dataframe
        data_df = df.copy()
    else:
        # Use the original dataframe
        data_df = df
    # Make sure that the columns is a list
    if isinstance(columns, str):
        columns = [columns]
    if not isinstance(columns, list):
        raise Exception(f&#39;ERROR: The `columns` argument must be specified as either a single string or a list of strings. Received input with type {type(columns)}.&#39;)
    print(&#39;Cleaning the categorical columns...&#39;)
    for col in utils.iterations_loop(columns):
        # Check if the column exists
        if col not in data_df.columns:
            raise Exception(&#39;ERROR: Column name not found in the dataframe.&#39;)
        if clean_name is True:
            # Clean the column&#39;s string values to have the same, standard format
            data_df = clean_categories_naming(data_df, col, clean_missing_values,
                                              specific_nan_strings, lower_case)
        if has_nan is True:
            # Fill NaN with &#34;missing_value&#34; name
            data_df[col] = data_df[col].fillna(value=&#39;missing_value&#39;)
        # Cast the variable into the built in pandas Categorical data type
        if isinstance(data_df, pd.DataFrame):
            data_df[col] = pd.Categorical(data_df[col])
    if isinstance(data_df, dd.DataFrame):
        data_df = data_df.categorize(columns)
    if get_new_column_names is True:
        # Find the previously existing column names
        old_column_names = data_df.columns
    print(&#39;Getting dummies...&#39;)
    # Apply the one hot encoding to the specified columns
    if isinstance(data_df, dd.DataFrame):
        ohe_df = dd.get_dummies(data_df, columns=columns)
    else:
        ohe_df = pd.get_dummies(data_df, columns=columns)
    if join_rows is True:
        # Columns which are one hot encoded
        ohe_columns = search_explore.list_boolean_columns(ohe_df, search_by_dtypes=search_by_dtypes)
        # Group the rows that have the same identifiers
        ohe_df = ohe_df.groupby(join_by).sum(min_count=1).reset_index()
        # Clip the one hot encoded columns to a maximum value of 1
        # (there might be duplicates which cause values bigger than 1)
        ohe_df.loc[:, ohe_columns] = ohe_df[ohe_columns].clip(upper=1)
    print(&#39;Done!&#39;)
    if get_new_column_names is True:
        # Find the new column names and output them
        new_column_names = list(set(ohe_df.columns) - set(old_column_names))
        new_column_names.sort()
        return ohe_df, new_column_names
    else:
        return ohe_df</code></pre>
</details>
</dd>
<dt id="data_utils.data_processing.remove_cols_with_many_nans"><code class="name flex">
<span>def <span class="ident">remove_cols_with_many_nans</span></span>(<span>df, nan_percent_thrsh=40, inplace=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove columns that have too many NaN's (missing values).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code></dt>
<dd>Dataframe that will be processed, to remove columns with high
percentages of missing values.</dd>
<dt><strong><code>nan_percent_thrsh</code></strong> :&ensp;<code>int</code> or <code>float</code>, default <code>40</code></dt>
<dd>Threshold value above which it's considered a column with too
many missing values. Measured in percentage of missing values,
in 100% format.</dd>
<dt><strong><code>inplace</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, the original dataframe will be used and modified
directly. Otherwise, a copy will be created and returned, without
changing the original dataframe.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code></dt>
<dd>Corrected dataframe, with columns removed that had too many
missing values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_cols_with_many_nans(df, nan_percent_thrsh=40, inplace=False):
    &#39;&#39;&#39;Remove columns that have too many NaN&#39;s (missing values).

    Parameters
    ----------
    df : pandas.DataFrame or dask.DataFrame
        Dataframe that will be processed, to remove columns with high
        percentages of missing values.
    nan_percent_thrsh : int or float, default 40
        Threshold value above which it&#39;s considered a column with too
        many missing values. Measured in percentage of missing values,
        in 100% format.
    inplace : bool, default False
        If set to True, the original dataframe will be used and modified
        directly. Otherwise, a copy will be created and returned, without
        changing the original dataframe.

    Returns
    -------
    df : pandas.DataFrame or dask.DataFrame
        Corrected dataframe, with columns removed that had too many
        missing values.
    &#39;&#39;&#39;
    if not inplace:
        # Make a copy of the data to avoid potentially unwanted changes to the original dataframe
        data_df = df.copy()
    else:
        # Use the original dataframe
        data_df = df
    # Find each column&#39;s missing values percentage
    nan_percent_df = search_explore.dataframe_missing_values(data_df)
    # Remove columns that exceed the missing values percentage threshold
    many_nans_cols = list(nan_percent_df[nan_percent_df.percent_missing &gt; nan_percent_thrsh].column_name)
    data_df = data_df.drop(many_nans_cols, axis = 1)
    return data_df</code></pre>
</details>
</dd>
<dt id="data_utils.data_processing.remove_rows_unmatched_key"><code class="name flex">
<span>def <span class="ident">remove_rows_unmatched_key</span></span>(<span>df, key, columns)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove rows corresponding to the keys that weren't in the dataframe merged at the right.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code></dt>
<dd>Dataframe resulting from a asof merge which will be searched for missing values.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>string</code></dt>
<dd>Name of the column which was used as the "by" key in the asof merge. Typically
represents a temporal feature from a time series, such as days or timestamps.</dd>
<dt><strong><code>columns</code></strong> :&ensp;<code>list</code> of <code>strings</code></dt>
<dd>Name of the column(s), originating from the dataframe which was merged at the
right, which should not have any missing values. If it has, it means that
the corresponding key wasn't present in the original dataframe. Even if there's
just one column to analyze, it should be received in list format.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code></dt>
<dd>Returns the input dataframe but without the rows which didn't have any values
in the right dataframe's features.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_rows_unmatched_key(df, key, columns):
    &#39;&#39;&#39;Remove rows corresponding to the keys that weren&#39;t in the dataframe merged at the right.

    Parameters
    ----------
    df : pandas.DataFrame or dask.DataFrame
        Dataframe resulting from a asof merge which will be searched for missing values.
    key : string
        Name of the column which was used as the &#34;by&#34; key in the asof merge. Typically
        represents a temporal feature from a time series, such as days or timestamps.
    columns : list of strings
        Name of the column(s), originating from the dataframe which was merged at the
        right, which should not have any missing values. If it has, it means that
        the corresponding key wasn&#39;t present in the original dataframe. Even if there&#39;s
        just one column to analyze, it should be received in list format.

    Returns
    -------
    df : pandas.DataFrame or dask.DataFrame
        Returns the input dataframe but without the rows which didn&#39;t have any values
        in the right dataframe&#39;s features.
    &#39;&#39;&#39;
    for k in utils.iterations_loop(df[key].unique()):
        # Variable that counts the number of columns which don&#39;t have any value
        # (i.e. all rows are missing values) for a given identifier &#39;k&#39;
        num_empty_columns = 0
        for col in columns:
            if df[df[key] == k][col].isnull().sum() == len(df[df[key] == k]):
                # Found one more column which is full of missing values for identifier &#39;k&#39;
                num_empty_columns += 1
        if num_empty_columns == len(columns):
            # Eliminate all rows corresponding to the analysed key if all the columns
            # are empty for the identifier &#39;k&#39;
            df = df[~(df[key] == k)]
    return df</code></pre>
</details>
</dd>
<dt id="data_utils.data_processing.rename_index"><code class="name flex">
<span>def <span class="ident">rename_index</span></span>(<span>df, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Renames the dataframe's index to a desired name. Specially important
for dask dataframes, as they don't support any elegant, one-line method
for this.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code></dt>
<dd>Dataframe whose index column will be renamed.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code></dt>
<dd>The new name for the index column.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>dask.DataFrame</code></dt>
<dd>Dataframe with a renamed index column.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename_index(df, name):
    &#39;&#39;&#39;Renames the dataframe&#39;s index to a desired name. Specially important
    for dask dataframes, as they don&#39;t support any elegant, one-line method
    for this.

    Parameters
    ----------
    df : pandas.DataFrame or dask.DataFrame
        Dataframe whose index column will be renamed.
    name : string
        The new name for the index column.

    Returns
    -------
    df : dask.DataFrame
        Dataframe with a renamed index column.
    &#39;&#39;&#39;
    if isinstance(df, dd.DataFrame):
        feat_names = set(df.columns)
        df = df.reset_index()
        orig_idx_name = set(df.columns) - feat_names
        orig_idx_name = orig_idx_name.pop()
        df = df.rename(columns={orig_idx_name: name})
        df = df.set_index(name)
    elif isinstance(df, pd.DataFrame):
        df.index.names = [name]
    else:
        raise Exception(f&#39;ERROR: Input &#34;df&#34; should either be a pandas dataframe or a dask dataframe, not type {type(df)}.&#39;)
    return df</code></pre>
</details>
</dd>
<dt id="data_utils.data_processing.save_chunked_data"><code class="name flex">
<span>def <span class="ident">save_chunked_data</span></span>(<span>df, file_name, n_chunks=None, batch_size=1, id_column=None, data_path='', format='feather')</span>
</code></dt>
<dd>
<div class="desc"><p>Save a dataframe in chunks, i.e. in separate files, so as to prevent
memory issues and other problems when loading it back again.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code></dt>
<dd>Dataframe which will be saved in chunks.</dd>
<dt><strong><code>file_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name to be given to the file.</dd>
<dt><strong><code>n_chunks</code></strong> :&ensp;<code>int</code>, default <code>None</code></dt>
<dd>Number of chunks, i.e. number of files, on which to split and save the
dataframe.</dd>
<dt><strong><code>batch_size</code></strong> :&ensp;<code>int</code>, default <code>1</code></dt>
<dd>Defines the batch size, i.e. the number of samples used in each
training iteration to update the model's weights.</dd>
<dt><strong><code>id_column</code></strong> :&ensp;<code>string</code>, default <code>None</code></dt>
<dd>Name of the column which corresponds to the sequence or subject identifier
in the dataframe. If specified, the data will be saved in files
containing a <code>batch_size</code> number of unique IDs. This is useful if we're
working with large datasets, which therefore need to be loaded file by
file, lazily, in each training or inference batch.</dd>
<dt><strong><code>data_path</code></strong> :&ensp;<code>str</code>, default <code>''</code></dt>
<dd>Directory path where the file will be stored.</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code>, default <code>'feather'</code></dt>
<dd>Data format used to saved the dataframe. Currently available options are
'feather'.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_chunked_data(df, file_name, n_chunks=None, batch_size=1,
                      id_column=None, data_path=&#39;&#39;, format=&#39;feather&#39;):
    &#39;&#39;&#39;Save a dataframe in chunks, i.e. in separate files, so as to prevent
    memory issues and other problems when loading it back again.

    Parameters
    ----------
    df : pandas.DataFrame or dask.DataFrame
        Dataframe which will be saved in chunks.
    file_name : str
        Name to be given to the file.
    n_chunks : int, default None
        Number of chunks, i.e. number of files, on which to split and save the
        dataframe.
    batch_size : int, default 1
        Defines the batch size, i.e. the number of samples used in each
        training iteration to update the model&#39;s weights.
    id_column : string, default None
        Name of the column which corresponds to the sequence or subject identifier
        in the dataframe. If specified, the data will be saved in files
        containing a `batch_size` number of unique IDs. This is useful if we&#39;re
        working with large datasets, which therefore need to be loaded file by
        file, lazily, in each training or inference batch.
    data_path : str, default &#39;&#39;
        Directory path where the file will be stored.
    format : str, default &#39;feather&#39;
        Data format used to saved the dataframe. Currently available options are
        &#39;feather&#39;.
    &#39;&#39;&#39;
    n_rows = len(df)
    format = str(format).lower()
    if format == &#39;feather&#39;:
        file_ext = &#39;.ftr&#39;
    else:
        raise Exception(f&#39;ERROR: Invalid data format &#34;{format}&#34;. Please choose one of the currently supported formats &#34;feather&#34;.&#39;)
    if n_chunks is not None:
        # Total number of rows per file
        chunk_size = int(n_rows / n_chunks)
        for i in du.utils.iterations_loop(range(n_chunks)):
            # Get a chunk of the dataframe
            if i &lt; n_chunks-1:
                df_i = df.iloc[i*chunk_size:(i+1)*chunk_size]
            else:
                df_i = df.iloc[i*chunk_size:]
            # Reset the index, so as to make it feather compatible
            df_i.reset_index(drop=True, inplace=True)
            # Save the current dataframe
            df_i.to_feather(f&#39;{data_path}{file_name}_{i}{file_ext}&#39;)
            # Remove the already saved dataframe from memory
            del df_i
    elif batch_size is not None and id_column is not None:
        # List of unique sequence identifiers
        ids = list(df[id_column].unique())
        # Number of unique IDs
        n_ids = len(ids)
        # Total number of files to be saved
        n_chunks = max(1, math.ceil(n_ids / batch_size))
        for i in du.utils.iterations_loop(range(n_chunks)):
            # Set the current batch&#39;s list of IDs
            if i &lt; n_chunks-1:
                ids_i = ids[i*batch_size:(i+1)*batch_size]
            else:
                ids_i = ids[i*batch_size:]
            # Get a chunk of the dataframe
            df_i = df[df[id_column].isin(ids_i)]
            # Reset the index, so as to make it feather compatible
            df_i.reset_index(drop=True, inplace=True)
            # Save the current dataframe
            df_i.to_feather(f&#39;{data_path}{file_name}_{i}{file_ext}&#39;)
            # Remove the already saved dataframe from memory
            del df_i
    else:
        raise Exception(f&#39;ERROR: Invalid set of input parameters. The user must either specify a number of chunks (`n_chunks`) to save the data or a batch size (`batch_size`) and an ID column (`id_column`) on which to fetch sequences.&#39;)</code></pre>
</details>
</dd>
<dt id="data_utils.data_processing.set_dosage_and_units"><code class="name flex">
<span>def <span class="ident">set_dosage_and_units</span></span>(<span>df, orig_column='dosage', new_column_names=['drug_dosage', 'drug_unit'])</span>
</code></dt>
<dd>
<div class="desc"><p>Separate medication dosage string column into numeric dosage and units
features.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code></dt>
<dd>Dataframe containing the medication dosage information.</dd>
<dt><strong><code>orig_column</code></strong> :&ensp;<code>string</code>, default <code>'dosage'</code></dt>
<dd>Name of the original column, which will be split in two.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code></dt>
<dd>Dataframe after adding the numeric dosage and units columns.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_dosage_and_units(df, orig_column=&#39;dosage&#39;, new_column_names=[&#39;drug_dosage&#39;, &#39;drug_unit&#39;]):
    &#39;&#39;&#39;Separate medication dosage string column into numeric dosage and units
    features.

    Parameters
    ----------
    df : pandas.DataFrame or dask.DataFrame
        Dataframe containing the medication dosage information.
    orig_column : string, default &#39;dosage&#39;
        Name of the original column, which will be split in two.

    Returns
    -------
    df : pandas.DataFrame or dask.DataFrame
        Dataframe after adding the numeric dosage and units columns.
    &#39;&#39;&#39;
    # Separate the dosage and unit data
    dosage_unit_data = df[orig_column].apply(__sep_dosage_units)
    # Make sure that the new columns are created
    for col in new_column_names:
        df[col] = np.nan
    # Add the new dosage and units columns
    df[new_column_names] = pd.DataFrame(dosage_unit_data.to_numpy().tolist(),
                                        index=dosage_unit_data.index)
    return df</code></pre>
</details>
</dd>
<dt id="data_utils.data_processing.signal_idx_derivative"><code class="name flex">
<span>def <span class="ident">signal_idx_derivative</span></span>(<span>s, time_scale='seconds', periods=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a series that contains the signal's index derivative, with the
same divisions (if needed) as the original data and on the desired time
scale.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>pandas.Series</code> or <code>dask.Series</code></dt>
<dd>Series which will be analyzed for outlier detection.</dd>
<dt><strong><code>time_scale</code></strong> :&ensp;<code>bool</code>, default <code>'seconds'</code></dt>
<dd>How to calculate derivatives, either with respect to the index values,
on the time scale of 'seconds', 'minutes', 'hours', 'days', 'months' or
'years', or just sequentially, just getting the difference between
consecutive values, 'False'. Only used if parameter 'signal' isn't set
to 'value'.</dd>
<dt><strong><code>periods</code></strong> :&ensp;<code>int</code>, default <code>1</code></dt>
<dd>Defines the steps to take when calculating the derivative. When set to 1,
it performs a normal backwards derivative. When set to 1, it performs a
normal forwards derivative.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>s_idx</code></strong> :&ensp;<code>pandas.Series</code> or <code>dask.Series</code></dt>
<dd>Index derivative signal, on the desired time scale.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_idx_derivative(s, time_scale=&#39;seconds&#39;, periods=1):
    &#39;&#39;&#39;Creates a series that contains the signal&#39;s index derivative, with the
    same divisions (if needed) as the original data and on the desired time
    scale.

    Parameters
    ----------
    s : pandas.Series or dask.Series
        Series which will be analyzed for outlier detection.
    time_scale : bool, default &#39;seconds&#39;
        How to calculate derivatives, either with respect to the index values,
        on the time scale of &#39;seconds&#39;, &#39;minutes&#39;, &#39;hours&#39;, &#39;days&#39;, &#39;months&#39; or
        &#39;years&#39;, or just sequentially, just getting the difference between
        consecutive values, &#39;False&#39;. Only used if parameter &#39;signal&#39; isn&#39;t set
        to &#39;value&#39;.
    periods : int, default 1
        Defines the steps to take when calculating the derivative. When set to 1,
        it performs a normal backwards derivative. When set to 1, it performs a
        normal forwards derivative.

    Returns
    -------
    s_idx : pandas.Series or dask.Series
        Index derivative signal, on the desired time scale.
    &#39;&#39;&#39;
    # Calculate the signal index&#39;s derivative
    s_idx = s.index.to_series().diff()
    if isinstance(s_idx, dd.DataFrame):
        # Make the new derivative have the same divisions as the original signal
        s_idx = (s_idx.to_frame().rename(columns={s.index.name:&#39;tmp_val&#39;})
                      .reset_index()
                      .set_index(s.index.name, sorted=True, divisions=s.divisions)
                      .tmp_val)
    # Convert derivative to the desired time scale
    if time_scale == &#39;seconds&#39;:
        s_idx = s_idx.dt.seconds
    elif time_scale == &#39;minutes&#39;:
        s_idx = s_idx.dt.seconds / 60
    elif time_scale == &#39;hours&#39;:
        s_idx = s_idx.dt.seconds / 3600
    elif time_scale == &#39;days&#39;:
        s_idx = s_idx.dt.seconds / 86400
    elif time_scale == &#39;months&#39;:
        s_idx = s_idx.dt.seconds / 2592000
    return s_idx</code></pre>
</details>
</dd>
<dt id="data_utils.data_processing.slopes_outlier_detect"><code class="name flex">
<span>def <span class="ident">slopes_outlier_detect</span></span>(<span>s, max_thrs=4, bidir_sens=0.5, threshold_type='std', time_scale='seconds', only_bir=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Detects outliers based on large variations on the signal's derivatives,
either in one direction or on both at the same time.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>pandas.Series</code> or <code>dask.Series</code></dt>
<dd>Series which will be analyzed for outlier detection.</dd>
<dt><strong><code>max_thrs</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Maximum threshold, i.e. no point can have a magnitude derivative value
deviate more than this threshold, in the signal that we're analyzing.</dd>
<dt><strong><code>bidir_sens</code></strong> :&ensp;<code>float</code>, default <code>0.5</code></dt>
<dd>Dictates how much more sensitive the algorithm is when a deviation (i.e.
large variation) is found on both sides of the data point / both
directions of the derivative. In other words, it's a factor that will be
multiplied by the usual one-directional threshold (<code>max_thrs</code>), from which
the resulting value will be used as the bidirectional threshold.</dd>
<dt><strong><code>threshold_type</code></strong> :&ensp;<code>string</code>, default <code>'std'</code></dt>
<dd>Determines if we're using threshold values with respect to the original
scale of derivative values, 'absolute', relative to the derivative's
mean, 'mean' or 'average', to the median, 'median' or to the standard
deviation, 'std'. As such, the possible settings are ['absolute', 'mean',
'average', 'median', 'std'].</dd>
<dt><strong><code>time_scale</code></strong> :&ensp;<code>string</code> or <code>bool</code>, default <code>'seconds'</code></dt>
<dd>How to calculate derivatives, either with respect to the index values,
on the time scale of 'seconds', 'minutes', 'hours', 'days', 'months' or
'years', or just sequentially, just getting the difference between
consecutive values, 'False'. Only used if parameter 'signal' isn't set
to 'value'.</dd>
<dt><strong><code>only_bir</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, the algorithm will only check for data points that have
large derivatives on both directions.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>outlier_s</code></strong> :&ensp;<code>pandas.Series</code> or <code>dask.Series</code></dt>
<dd>Boolean series indicating where the detected outliers are.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slopes_outlier_detect(s, max_thrs=4, bidir_sens=0.5, threshold_type=&#39;std&#39;,
                          time_scale=&#39;seconds&#39;, only_bir=False):
    &#39;&#39;&#39;Detects outliers based on large variations on the signal&#39;s derivatives,
    either in one direction or on both at the same time.

    Parameters
    ----------
    s : pandas.Series or dask.Series
        Series which will be analyzed for outlier detection.
    max_thrs : int or float
        Maximum threshold, i.e. no point can have a magnitude derivative value
        deviate more than this threshold, in the signal that we&#39;re analyzing.
    bidir_sens : float, default 0.5
        Dictates how much more sensitive the algorithm is when a deviation (i.e.
        large variation) is found on both sides of the data point / both
        directions of the derivative. In other words, it&#39;s a factor that will be
        multiplied by the usual one-directional threshold (`max_thrs`), from which
        the resulting value will be used as the bidirectional threshold.
    threshold_type : string, default &#39;std&#39;
        Determines if we&#39;re using threshold values with respect to the original
        scale of derivative values, &#39;absolute&#39;, relative to the derivative&#39;s
        mean, &#39;mean&#39; or &#39;average&#39;, to the median, &#39;median&#39; or to the standard
        deviation, &#39;std&#39;. As such, the possible settings are [&#39;absolute&#39;, &#39;mean&#39;,
        &#39;average&#39;, &#39;median&#39;, &#39;std&#39;].
    time_scale : string or bool, default &#39;seconds&#39;
        How to calculate derivatives, either with respect to the index values,
        on the time scale of &#39;seconds&#39;, &#39;minutes&#39;, &#39;hours&#39;, &#39;days&#39;, &#39;months&#39; or
        &#39;years&#39;, or just sequentially, just getting the difference between
        consecutive values, &#39;False&#39;. Only used if parameter &#39;signal&#39; isn&#39;t set
        to &#39;value&#39;.
    only_bir : bool, default False
        If set to True, the algorithm will only check for data points that have
        large derivatives on both directions.

    Returns
    -------
    outlier_s : pandas.Series or dask.Series
        Boolean series indicating where the detected outliers are.
    &#39;&#39;&#39;
    # Calculate the difference between consecutive values
    bckwrds_deriv = s.diff()
    frwrds_deriv = s.diff(-1)
    if time_scale is not None:
        # Derivate by the index values
        bckwrds_deriv = bckwrds_deriv / signal_idx_derivative(bckwrds_deriv, time_scale, periods=1)
        frwrds_deriv = frwrds_deriv / signal_idx_derivative(frwrds_deriv, time_scale, periods=-1)
    if threshold_type.lower() == &#39;absolute&#39;:
        bckwrds_deriv = bckwrds_deriv
        frwrds_deriv = frwrds_deriv
    elif threshold_type.lower() == &#39;mean&#39; or threshold_type.lower() == &#39;average&#39;:
        bckwrds_deriv_mean = bckwrds_deriv.mean()
        frwrds_deriv_mean = frwrds_deriv.mean()
        if isinstance(bckwrds_deriv, dd.DataFrame):
            # Make sure that the value is computed, in case we&#39;re using Dask
            bckwrds_deriv_mean = bckwrds_deriv_mean.compute()
            frwrds_deriv_mean = frwrds_deriv_mean.compute()
        # Normalize by the average value
        bckwrds_deriv = bckwrds_deriv / bckwrds_deriv_mean
        frwrds_deriv = frwrds_deriv / frwrds_deriv_mean
    elif threshold_type.lower() == &#39;median&#39;:
        bckwrds_deriv_median = bckwrds_deriv.median()
        frwrds_deriv_median = frwrds_deriv.median()
        if isinstance(bckwrds_deriv, dd.DataFrame):
            # Make sure that the value is computed, in case we&#39;re using Dask
            bckwrds_deriv_median = bckwrds_deriv_median.compute()
            frwrds_deriv_median = frwrds_deriv_median.compute()
        # Normalize by the median value
        bckwrds_deriv = bckwrds_deriv / bckwrds_deriv_median
        frwrds_deriv = frwrds_deriv / frwrds_deriv_median
    elif threshold_type.lower() == &#39;std&#39;:
        bckwrds_deriv_mean = bckwrds_deriv.mean()
        frwrds_deriv_mean = frwrds_deriv.mean()
        bckwrds_deriv_std = bckwrds_deriv.std()
        frwrds_deriv_std = frwrds_deriv.std()
        if isinstance(bckwrds_deriv, dd.DataFrame):
            # Make sure that the values are computed, in case we&#39;re using Dask
            bckwrds_deriv_mean = bckwrds_deriv_mean.compute()
            frwrds_deriv_mean = frwrds_deriv_mean.compute()
            bckwrds_deriv_std = bckwrds_deriv_std.compute()
            frwrds_deriv_std = frwrds_deriv_std.compute()
        # Normalize by the average and standard deviation values
        bckwrds_deriv = (bckwrds_deriv - bckwrds_deriv_mean) / bckwrds_deriv_std
        frwrds_deriv = (frwrds_deriv - frwrds_deriv_mean) / frwrds_deriv_std
    else:
        raise Exception(&#39;ERROR: Invalid value type. It must be &#34;absolute&#34;, &#34;mean&#34;, &#34;average&#34;, &#34;median&#34; or &#34;std&#34;, not {threshold_type}.&#39;)

    # Bidirectional threshold, to be used when observing both directions of the derivative
    bidir_max = bidir_sens * max_thrs
    if only_bir is True:
        # Search for outliers on both derivatives at the same time, always on their respective magnitudes
        outlier_s = (bckwrds_deriv.abs() &gt; bidir_max) &amp; (frwrds_deriv.abs() &gt; bidir_max)
    else:
        # Search for outliers on each individual derivative, followed by both at the same time with a lower threshold, always on their respective magnitudes
        outlier_s = ((bckwrds_deriv.abs() &gt; max_thrs) | (frwrds_deriv.abs() &gt; max_thrs)
                     | ((bckwrds_deriv.abs() &gt; bidir_max) &amp; (frwrds_deriv.abs() &gt; bidir_max)))
    return outlier_s</code></pre>
</details>
</dd>
<dt id="data_utils.data_processing.standardize_missing_values"><code class="name flex">
<span>def <span class="ident">standardize_missing_values</span></span>(<span>x, specific_nan_strings=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Apply function to be used in replacing missing value representations with
the standard NumPy NaN value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>str, int</code> or <code>float</code></dt>
<dd>Value to be analyzed and replaced with NaN, if it has a missing value
representation.</dd>
<dt><strong><code>specific_nan_strings</code></strong> :&ensp;<code>list</code> of <code>strings</code>, default <code>[]</code></dt>
<dd>Parameter where the user can specify additional strings that
should correspond to missing values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>str, int</code> or <code>float</code></dt>
<dd>Corrected value, with standardized missing value representation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def standardize_missing_values(x, specific_nan_strings=[]):
    &#39;&#39;&#39;Apply function to be used in replacing missing value representations with
    the standard NumPy NaN value.

    Parameters
    ----------
    x : str, int or float
        Value to be analyzed and replaced with NaN, if it has a missing value
        representation.
    specific_nan_strings : list of strings, default []
        Parameter where the user can specify additional strings that
        should correspond to missing values.

    Returns
    -------
    x : str, int or float
        Corrected value, with standardized missing value representation.
    &#39;&#39;&#39;
    if isinstance(x, str):
        if utils.is_string_nan(x, specific_nan_strings):
            return np.nan
        else:
            return x
    else:
        return x</code></pre>
</details>
</dd>
<dt id="data_utils.data_processing.standardize_missing_values_df"><code class="name flex">
<span>def <span class="ident">standardize_missing_values_df</span></span>(<span>df, see_progress=True, specific_nan_strings=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Replace all elements in a dataframe that have a missing value
representation with the standard NumPy NaN value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code></dt>
<dd>Dataframe to be analyzed and have its content replaced with NaN,
wherever a missing value representation is found.</dd>
<dt><strong><code>see_progress</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If set to True, a progress bar will show up indicating the execution
of the normalization calculations.</dd>
<dt><strong><code>specific_nan_strings</code></strong> :&ensp;<code>list</code> of <code>strings</code>, default <code>[]</code></dt>
<dd>Parameter where the user can specify additional strings that
should correspond to missing values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code></dt>
<dd>Corrected dataframe, with standardized missing value representation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def standardize_missing_values_df(df, see_progress=True, specific_nan_strings=[]):
    &#39;&#39;&#39;Replace all elements in a dataframe that have a missing value
    representation with the standard NumPy NaN value.

    Parameters
    ----------
    df : pandas.DataFrame or dask.DataFrame
        Dataframe to be analyzed and have its content replaced with NaN,
        wherever a missing value representation is found.
    see_progress : bool, default True
        If set to True, a progress bar will show up indicating the execution
        of the normalization calculations.
    specific_nan_strings : list of strings, default []
        Parameter where the user can specify additional strings that
        should correspond to missing values.

    Returns
    -------
    df : pandas.DataFrame or dask.DataFrame
        Corrected dataframe, with standardized missing value representation.
    &#39;&#39;&#39;
    for feature in utils.iterations_loop(df.columns, see_progress=see_progress):
        if isinstance(df, dd.DataFrame):
            df[feature] = df[feature].apply(lambda x: standardize_missing_values(x, specific_nan_strings),
                                            meta=df[feature]._meta.dtypes)
        elif isinstance(df, pd.DataFrame):
            df[feature] = df[feature].apply(lambda x: standardize_missing_values(x, specific_nan_strings))
        else:
            raise Exception(f&#39;ERROR: Input &#34;df&#34; should either be a pandas dataframe or a dask dataframe, not type {type(df)}.&#39;)
    return df</code></pre>
</details>
</dd>
<dt id="data_utils.data_processing.threshold_outlier_detect"><code class="name flex">
<span>def <span class="ident">threshold_outlier_detect</span></span>(<span>s, max_thrs=None, min_thrs=None, threshold_type='absolute', signal_type='value', time_scale='seconds', derivate_direction='backwards')</span>
</code></dt>
<dd>
<div class="desc"><p>Detects outliers based on predetermined thresholds.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>pandas.Series</code> or <code>dask.Series</code></dt>
<dd>Series which will be analyzed for outlier detection.</dd>
<dt><strong><code>max_thrs</code></strong> :&ensp;<code>int</code> or <code>float</code>, default <code>None</code></dt>
<dd>Maximum threshold, i.e. no normal value can be larger than this
threshold, in the signal (or its n-order derivative) that we're
analyzing.</dd>
<dt><strong><code>min_thrs</code></strong> :&ensp;<code>int</code> or <code>float</code>, default <code>None</code></dt>
<dd>Minimum threshold, i.e. no normal value can be smaller than this
threshold, in the signal (or its n-order derivative) that we're
analyzing.</dd>
<dt><strong><code>threshold_type</code></strong> :&ensp;<code>string</code>, default <code>'absolute'</code></dt>
<dd>Determines if we're using threshold values with respect to the original
scale of values, 'absolute', relative to the signal's mean, 'mean' or
'average', to the median, 'median' or to the standard deviation, 'std'.
As such, the possible settings are ['absolute', 'mean', 'average',
'median', 'std'].</dd>
<dt><strong><code>signal_type</code></strong> :&ensp;<code>string</code>, default <code>'value'</code></dt>
<dd>Sets if we're analyzing the original signal value, 'value', its first
derivative, 'derivative' or 'speed', or its second derivative, 'second
derivative' or 'acceleration'. As such, the possible settings are
['value', 'derivative', 'speed', 'second derivative', 'acceleration'].</dd>
<dt><strong><code>time_scale</code></strong> :&ensp;<code>string</code> or <code>bool</code>, default <code>'seconds'</code></dt>
<dd>How to calculate derivatives, either with respect to the index values,
on the time scale of 'seconds', 'minutes', 'hours', 'days', 'months' or
'years', or just sequentially, just getting the difference between
consecutive values, 'False'. Only used if parameter 'signal' isn't set
to 'value'.</dd>
<dt><strong><code>derivate_direction</code></strong> :&ensp;<code>string</code>, default <code>'backwards'</code></dt>
<dd>The direction in which we calculate the derivative, either comparing to
previous values, 'backwards', or to the next values, 'forwards'. As such,
the possible settings are ['backwards', 'forwards']. Only used if
parameter 'signal' isn't set to 'value'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>outlier_s</code></strong> :&ensp;<code>pandas.Series</code> or <code>dask.Series</code></dt>
<dd>Boolean series indicating where the detected outliers are.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def threshold_outlier_detect(s, max_thrs=None, min_thrs=None, threshold_type=&#39;absolute&#39;,
                             signal_type=&#39;value&#39;, time_scale=&#39;seconds&#39;,
                             derivate_direction=&#39;backwards&#39;):
    &#39;&#39;&#39;Detects outliers based on predetermined thresholds.

    Parameters
    ----------
    s : pandas.Series or dask.Series
        Series which will be analyzed for outlier detection.
    max_thrs : int or float, default None
        Maximum threshold, i.e. no normal value can be larger than this
        threshold, in the signal (or its n-order derivative) that we&#39;re
        analyzing.
    min_thrs : int or float, default None
        Minimum threshold, i.e. no normal value can be smaller than this
        threshold, in the signal (or its n-order derivative) that we&#39;re
        analyzing.
    threshold_type : string, default &#39;absolute&#39;
        Determines if we&#39;re using threshold values with respect to the original
        scale of values, &#39;absolute&#39;, relative to the signal&#39;s mean, &#39;mean&#39; or
        &#39;average&#39;, to the median, &#39;median&#39; or to the standard deviation, &#39;std&#39;.
        As such, the possible settings are [&#39;absolute&#39;, &#39;mean&#39;, &#39;average&#39;,
        &#39;median&#39;, &#39;std&#39;].
    signal_type : string, default &#39;value&#39;
        Sets if we&#39;re analyzing the original signal value, &#39;value&#39;, its first
        derivative, &#39;derivative&#39; or &#39;speed&#39;, or its second derivative, &#39;second
        derivative&#39; or &#39;acceleration&#39;. As such, the possible settings are
        [&#39;value&#39;, &#39;derivative&#39;, &#39;speed&#39;, &#39;second derivative&#39;, &#39;acceleration&#39;].
    time_scale : string or bool, default &#39;seconds&#39;
        How to calculate derivatives, either with respect to the index values,
        on the time scale of &#39;seconds&#39;, &#39;minutes&#39;, &#39;hours&#39;, &#39;days&#39;, &#39;months&#39; or
        &#39;years&#39;, or just sequentially, just getting the difference between
        consecutive values, &#39;False&#39;. Only used if parameter &#39;signal&#39; isn&#39;t set
        to &#39;value&#39;.
    derivate_direction : string, default &#39;backwards&#39;
        The direction in which we calculate the derivative, either comparing to
        previous values, &#39;backwards&#39;, or to the next values, &#39;forwards&#39;. As such,
        the possible settings are [&#39;backwards&#39;, &#39;forwards&#39;]. Only used if
        parameter &#39;signal&#39; isn&#39;t set to &#39;value&#39;.

    Returns
    -------
    outlier_s : pandas.Series or dask.Series
        Boolean series indicating where the detected outliers are.
    &#39;&#39;&#39;
    if signal_type.lower() == &#39;value&#39;:
        signal = s
    elif signal_type.lower() == &#39;derivative&#39; or signal_type.lower() == &#39;speed&#39;:
        if derivate_direction.lower() == &#39;backwards&#39;:
            periods = 1
        elif derivate_direction.lower() == &#39;forwards&#39;:
            periods = -1
        else:
            raise Exception(f&#39;ERROR: Invalid derivative direction. It must either be &#34;backwards&#34; or &#34;forwards&#34;, not {derivate_direction}.&#39;)
        # Calculate the difference between consecutive values
        signal = s.diff(periods)
        if time_scale is not None:
            # Derivate by the index values
            signal = signal / signal_idx_derivative(signal, time_scale, periods)
    elif (signal_type.lower() == &#39;second derivative&#39;
          or signal_type.lower() == &#39;acceleration&#39;):
        if derivate_direction.lower() == &#39;backwards&#39;:
            periods = 1
        elif derivate_direction.lower() == &#39;forwards&#39;:
            periods = -1
        else:
            raise Exception(f&#39;ERROR: Invalid derivative direction. It must either be &#34;backwards&#34; or &#34;forwards&#34;, not {derivate_direction}.&#39;)
        # Calculate the difference between consecutive values
        signal = s.diff(periods).diff(periods)
        if time_scale is not None:
            # Derivate by the index values
            signal = signal / signal_idx_derivative(signal, time_scale, periods)
    else:
        raise Exception(&#39;ERROR: Invalid signal type. It must be &#34;value&#34;, &#34;derivative&#34;, &#34;speed&#34;, &#34;second derivative&#34; or &#34;acceleration&#34;, not {signal}.&#39;)
    if threshold_type.lower() == &#39;absolute&#39;:
        signal = signal
    elif threshold_type.lower() == &#39;mean&#39; or threshold_type.lower() == &#39;average&#39;:
        signal_mean = signal.mean()
        if isinstance(signal, dd.DataFrame):
            # Make sure that the value is computed, in case we&#39;re using Dask
            signal_mean = signal_mean.compute()
        # Normalize by the average value
        signal = signal / signal_mean
    elif threshold_type.lower() == &#39;median&#39;:
        if isinstance(signal, dd.DataFrame):
            # Make sure that the value is computed, in case we&#39;re using Dask
            signal_median = signal.compute().median()
        else:
            signal_median = signal.median()
        # Normalize by the median value
        signal = signal / signal_median
    elif threshold_type.lower() == &#39;std&#39;:
        signal_mean = signal.mean()
        signal_std = signal.std()
        if isinstance(signal, dd.DataFrame):
            # Make sure that the values are computed, in case we&#39;re using Dask
            signal_mean = signal_mean.compute()
            signal_std = signal_std.compute()
        # Normalize by the average and standard deviation values
        signal = (signal - signal_mean) / signal_std
    else:
        raise Exception(f&#39;ERROR: Invalid value type. It must be &#34;absolute&#34;, &#34;mean&#34;, &#34;average&#34;, &#34;median&#34; or &#34;std&#34;, not {threshold_type}.&#39;)

    # Search for outliers based on the given thresholds
    if max_thrs is not None and min_thrs is not None:
        outlier_s = (signal &gt; max_thrs) | (signal &lt; min_thrs)
    elif max_thrs is not None:
        outlier_s = signal &gt; max_thrs
    elif min_thrs is not None:
        outlier_s = signal &lt; min_thrs
    else:
        raise Exception(&#39;ERROR: At least a maximum or a minimum threshold must be set. Otherwise, no outlier will ever be detected.&#39;)

    return outlier_s</code></pre>
</details>
</dd>
<dt id="data_utils.data_processing.transpose_dataframe"><code class="name flex">
<span>def <span class="ident">transpose_dataframe</span></span>(<span>df, column_to_transpose=None, inplace=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Transpose a dataframe, either by its original index or through a specific
column, which will be converted to the new column names (i.e. the header).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code></dt>
<dd>Dataframe that will be transposed.</dd>
<dt><strong><code>column_to_transpose</code></strong> :&ensp;<code>string</code>, default <code>None</code></dt>
<dd>If specified, the given column will be used as the new column names, with
its unique values forming the new dataframe's header. Otherwise, the
dataframe will be transposed on its original index.</dd>
<dt><strong><code>inplace</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If set to True, the original tensor or dataframe will be used and modified
directly. Otherwise, a copy will be created and returned, without
changing the original tensor or dataframe.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>pandas.DataFrame</code> or <code>dask.DataFrame</code></dt>
<dd>Transposed dataframe.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transpose_dataframe(df, column_to_transpose=None, inplace=False):
    &#39;&#39;&#39;Transpose a dataframe, either by its original index or through a specific
    column, which will be converted to the new column names (i.e. the header).

    Parameters
    ----------
    data : pandas.DataFrame or dask.DataFrame
        Dataframe that will be transposed.
    column_to_transpose : string, default None
        If specified, the given column will be used as the new column names, with
        its unique values forming the new dataframe&#39;s header. Otherwise, the
        dataframe will be transposed on its original index.
    inplace : bool, default False
        If set to True, the original tensor or dataframe will be used and modified
        directly. Otherwise, a copy will be created and returned, without
        changing the original tensor or dataframe.

    Returns
    -------
    data : pandas.DataFrame or dask.DataFrame
        Transposed dataframe.
    &#39;&#39;&#39;
    if not inplace:
        # Make a copy of the data to avoid potentially unwanted changes to the original dataframe
        data_df = df.copy()
    else:
        # Use the original dataframe
        data_df = df
    if column_to_transpose is not None:
        # Set as index the column that has the desired column names as values
        data_df = data_df.set_index(column_to_transpose)
    if isinstance(data_df, pd.DataFrame):
        data_df = data_df.transpose()
    elif isinstance(data_df, dd.DataFrame):
        data_df = (dd.from_pandas(data_df.compute().transpose(),
                                  npartitions=data_df.npartitions))
    else:
        raise Exception(f&#39;ERROR: The input data must either be a Pandas dataframe or a Dask dataframe, not {type(df)}.&#39;)
    return data_df</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="data_utils" href="index.html">data_utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="data_utils.data_processing.apply_minmax_denorm" href="#data_utils.data_processing.apply_minmax_denorm">apply_minmax_denorm</a></code></li>
<li><code><a title="data_utils.data_processing.apply_minmax_norm" href="#data_utils.data_processing.apply_minmax_norm">apply_minmax_norm</a></code></li>
<li><code><a title="data_utils.data_processing.apply_zscore_denorm" href="#data_utils.data_processing.apply_zscore_denorm">apply_zscore_denorm</a></code></li>
<li><code><a title="data_utils.data_processing.apply_zscore_norm" href="#data_utils.data_processing.apply_zscore_norm">apply_zscore_norm</a></code></li>
<li><code><a title="data_utils.data_processing.category_to_feature" href="#data_utils.data_processing.category_to_feature">category_to_feature</a></code></li>
<li><code><a title="data_utils.data_processing.category_to_feature_big_data" href="#data_utils.data_processing.category_to_feature_big_data">category_to_feature_big_data</a></code></li>
<li><code><a title="data_utils.data_processing.clean_categories_naming" href="#data_utils.data_processing.clean_categories_naming">clean_categories_naming</a></code></li>
<li><code><a title="data_utils.data_processing.clean_naming" href="#data_utils.data_processing.clean_naming">clean_naming</a></code></li>
<li><code><a title="data_utils.data_processing.denormalize_data" href="#data_utils.data_processing.denormalize_data">denormalize_data</a></code></li>
<li><code><a title="data_utils.data_processing.get_clean_label" href="#data_utils.data_processing.get_clean_label">get_clean_label</a></code></li>
<li><code><a title="data_utils.data_processing.load_chunked_data" href="#data_utils.data_processing.load_chunked_data">load_chunked_data</a></code></li>
<li><code><a title="data_utils.data_processing.merge_columns" href="#data_utils.data_processing.merge_columns">merge_columns</a></code></li>
<li><code><a title="data_utils.data_processing.merge_values" href="#data_utils.data_processing.merge_values">merge_values</a></code></li>
<li><code><a title="data_utils.data_processing.missing_values_imputation" href="#data_utils.data_processing.missing_values_imputation">missing_values_imputation</a></code></li>
<li><code><a title="data_utils.data_processing.normalize_data" href="#data_utils.data_processing.normalize_data">normalize_data</a></code></li>
<li><code><a title="data_utils.data_processing.one_hot_encoding_dataframe" href="#data_utils.data_processing.one_hot_encoding_dataframe">one_hot_encoding_dataframe</a></code></li>
<li><code><a title="data_utils.data_processing.remove_cols_with_many_nans" href="#data_utils.data_processing.remove_cols_with_many_nans">remove_cols_with_many_nans</a></code></li>
<li><code><a title="data_utils.data_processing.remove_rows_unmatched_key" href="#data_utils.data_processing.remove_rows_unmatched_key">remove_rows_unmatched_key</a></code></li>
<li><code><a title="data_utils.data_processing.rename_index" href="#data_utils.data_processing.rename_index">rename_index</a></code></li>
<li><code><a title="data_utils.data_processing.save_chunked_data" href="#data_utils.data_processing.save_chunked_data">save_chunked_data</a></code></li>
<li><code><a title="data_utils.data_processing.set_dosage_and_units" href="#data_utils.data_processing.set_dosage_and_units">set_dosage_and_units</a></code></li>
<li><code><a title="data_utils.data_processing.signal_idx_derivative" href="#data_utils.data_processing.signal_idx_derivative">signal_idx_derivative</a></code></li>
<li><code><a title="data_utils.data_processing.slopes_outlier_detect" href="#data_utils.data_processing.slopes_outlier_detect">slopes_outlier_detect</a></code></li>
<li><code><a title="data_utils.data_processing.standardize_missing_values" href="#data_utils.data_processing.standardize_missing_values">standardize_missing_values</a></code></li>
<li><code><a title="data_utils.data_processing.standardize_missing_values_df" href="#data_utils.data_processing.standardize_missing_values_df">standardize_missing_values_df</a></code></li>
<li><code><a title="data_utils.data_processing.threshold_outlier_detect" href="#data_utils.data_processing.threshold_outlier_detect">threshold_outlier_detect</a></code></li>
<li><code><a title="data_utils.data_processing.transpose_dataframe" href="#data_utils.data_processing.transpose_dataframe">transpose_dataframe</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>